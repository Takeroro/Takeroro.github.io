<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="上帝只救自救者">
<meta property="og:type" content="website">
<meta property="og:title" content="I&#39;m Terrence">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="I&#39;m Terrence">
<meta property="og:description" content="上帝只救自救者">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="I&#39;m Terrence">
<meta name="twitter:description" content="上帝只救自救者">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title> I'm Terrence </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">I'm Terrence</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/12/ffmpeg 实操/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/10/12/ffmpeg 实操/" itemprop="url">
                  ffmpeg 实操
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-12T17:08:50+08:00">
                2020-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="0x1背景"><a href="#0x1背景" class="headerlink" title="0x1背景"></a>0x1背景</h2><p>前段时间去三亚深潜了，因为考证回来后第一次的 FD, 为了记录下所见的海底世界，临出发前在淘宝租了台 go pro 7。在整个使用过程中，除了2次无故的死机外，拍得还是挺顺心的。然后回来得把sd卡的视频转移到自己的电脑，这才发现，几天下来的视频已达到 80多g （一个 8 min 的视频就8g了），md,我的mac book 才多少g啊，哪吃得下！<br>因此把这些视频压缩这个任务优先级已经很高了，在这个契机下，我去复习了下视频编解码相关的知识。</p>
<h2 id="0x2-视频压缩（编码）"><a href="#0x2-视频压缩（编码）" class="headerlink" title="0x2 视频压缩（编码）"></a>0x2 视频压缩（编码）</h2><p>所谓视频，其实就是很多张图片，在一定时间内轮播完。比如，如果视频的帧率是24帧的，就是1秒内轮播完24张图片。go pro 的帧率在默认模式去到了60帧了，还能不大吗··<br>然后这里的压缩，就可以分为两种了，一种是帧内压缩，即图片压缩，另一种是帧间压缩，简要说来就是对于前后两帧，编码后面那帧时，只把基于前面那一帧不同的地方给编码，这样对于前后两帧差别不大的地方，压缩率是很高的。</p>
<h3 id="0x2-1-ffmpeg"><a href="#0x2-1-ffmpeg" class="headerlink" title="0x2-1 ffmpeg"></a>0x2-1 ffmpeg</h3><p>ffmpeg 是一套功能强大的，开源的，音视频处理工具，功能包括但不限于包括<a href="https://baike.baidu.com/item/视频采集" target="_blank" rel="noopener">视频采集</a>功能、<a href="https://baike.baidu.com/item/视频格式转换" target="_blank" rel="noopener">视频格式转换</a>、视频抓图、给视频加水印等。</p>
<h3 id="0x2-2-码率，-帧率，分辨率"><a href="#0x2-2-码率，-帧率，分辨率" class="headerlink" title="0x2-2 码率， 帧率，分辨率"></a>0x2-2 码率， 帧率，分辨率</h3><p>帧率 （FPS）：1s 中传输图片的的数量，主要影响视频的流畅度，帧率越高，流畅度越好，帧率越低，画面就越有跳跃感。视频一般的帧率有24就很流畅了，而 go pro 采集的时候有两种模式去到帧率去到 60 才有稳定的功能，导出的视频能不大才怪</p>
<p>分辨率：图片的尺寸，分辨率越大，图片的尺寸就越大了</p>
<p>码率：每 s 图片压缩后的数据量，而码率 x 时长就是视频的体积了。分辨率 x 帧率 = 每 s 在压缩前的数据量。</p>
<p>在码率一定的情况下，分辨率与图像清晰度成反比关系，分辨率越大，图像就越不清晰。</p>
<p>在分辨率一定的情况下，码率与图像清晰度成正比关系，码率越大，图像就越清晰。</p>
<h3 id="0x2-3-压缩效果"><a href="#0x2-3-压缩效果" class="headerlink" title="0x2-3 压缩效果"></a>0x2-3 压缩效果</h3><p>可以尝试在帧率，分辨率，码率三个维度作下牺牲，来改变视频的体积。</p>
<p>-r 改 帧率<br><code>ffmpeg -i input -r 24</code></p>
<p>-s 改 分辨率<br><code>ffmpeg -i input -s 640x480</code></p>
<p>-b:v 改 码率</p>
<p><code>ffmpeg -i input -b:v 64k</code></p>
<p>直接修改其中一个或多个参数，都可以来打到压缩体积的效果，但画质惨不忍睹啊，由于硬盘容量实在有限，原视频在写这篇日志之前已经删光了，无法上图对比··</p>
<h3 id="0x2-4-h265"><a href="#0x2-4-h265" class="headerlink" title="0x2-4 h265"></a>0x2-4 h265</h3><p><code>ffmpeg -i input</code> 这句可以看到原来的视频已经是用了 h264 编码的了，业界其实还有一种更先进的 h265 编码，立刻去尝试下！</p>
<p>安装 ffmpeg 这一块就不在这里详述了，这里主要在用 ffmpeg 进行 h265 编码遇到过的坑。</p>
<p>H265 需要借助 libx265 的库，而通过 brew 的方式来安装 ffmpeg 的话，由于 homebrew 本身是不支持带有 options 的方式安装 ffmpeg , 所以这种方式无法一步到位地把 ffmpeg 跟 libx265 关联起来，这个时候，需要借助 <a href="https://link.zhihu.com/?target=https%3A//github.com/homebrew-ffmpeg/homebrew-ffmpeg" target="_blank" rel="noopener">homebrew-ffmpeg</a> 这个第三方库来给 ffmpeg 添加options 及 特性，而 这个库默认把 libx265 的能力添加进来了。</p>
<p>按步骤执行以下几句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">brew install ffmpeg</span><br><span class="line"></span><br><span class="line">brew tap homebrew-ffmpeg/ffmpeg</span><br><span class="line"></span><br><span class="line">brew install homebrew-ffmpeg/ffmpeg/ffmpeg</span><br><span class="line"></span><br><span class="line">//关联 ffmpeg</span><br><span class="line">brew link ffmpeg</span><br></pre></td></tr></table></figure>
<p>至此， 命令行的 ffmpeg 就有了 libx265 的能力了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i /Users/mac/Desktop/mp4/GH010105.MP4 -c:v libx265  /Users/mac/Documents/newFiles/GH010105_h265_1.mp4</span><br></pre></td></tr></table></figure>
<p>原体积 8g 的 时长 8min的 MP4文件，经 h265 转换后，体积为 300M+，视频展示效果从肉眼上已经很难分辨出有什么不同，经过老婆的检验，清晰度是 ok 的。唯一有点不足的是，转换时间太长了，转换60+个文件，用下面这个批量脚本去跑，跑了一整天才全部完成··</p>
<h3 id="批量转-h265"><a href="#批量转-h265" class="headerlink" title="批量转 h265"></a>批量转 h265</h3><p>要转视频实在太多了，于是用 python 写了个批量转换 h265 的脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python /Users/mac/Documents/pythonTest/test.py /Users/mac/Desktop/mp4  /Users/mac/Desktop/mp4Output</span><br></pre></td></tr></table></figure>
<p>指定输入文件夹，输出文件夹即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFilesIn</span><span class="params">(path)</span> :</span></span><br><span class="line">	g = os.walk(path)  </span><br><span class="line">	sourceFileList = []</span><br><span class="line">	<span class="keyword">for</span> path,dir_list,file_list <span class="keyword">in</span> g:  </span><br><span class="line">	    <span class="keyword">for</span> file_name <span class="keyword">in</span> file_list:  </span><br><span class="line">	        sourceFileList.append(os.path.join(path, file_name))</span><br><span class="line">	<span class="keyword">return</span> sourceFileList</span><br><span class="line"></span><br><span class="line"><span class="comment"># ffmpeg -i /Users/mac/Desktop/mp4/GH010105.MP4 -c:v libx265  /Users/mac/Documents/newFiles/GH010105_h265_1.mp4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convertToH265</span><span class="params">(file)</span>:</span></span><br><span class="line">	print(<span class="string">"############"</span>)</span><br><span class="line">	outputFilePath = outputPath +<span class="string">'/'</span>+ os.path.basename(file)</span><br><span class="line">	print(<span class="string">"输出文件："</span>+outputFilePath)</span><br><span class="line">	print(file)</span><br><span class="line">	print(<span class="string">"======="</span>)</span><br><span class="line">	print(os.system(<span class="string">'ffmpeg -i '</span> + str(file) + <span class="string">" -c:v libx265 "</span> + outputFilePath))</span><br><span class="line"></span><br><span class="line">args = sys.argv</span><br><span class="line"><span class="keyword">print</span> (args[<span class="number">1</span>])</span><br><span class="line">inputPath = args[<span class="number">1</span>]</span><br><span class="line">outputPath = args[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"输入路径："</span>+inputPath)</span><br><span class="line">print(<span class="string">"输出路径："</span>+outputPath)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> getFilesIn(inputPath):</span><br><span class="line">	print(<span class="string">"开始转换： "</span>+file+<span class="string">"  basename: "</span>+os.path.basename(file))</span><br><span class="line">	convertToH265(file)</span><br></pre></td></tr></table></figure>
<h3 id="视频合并"><a href="#视频合并" class="headerlink" title="视频合并"></a>视频合并</h3><p>这个需求是来源于从go pro 导出的时长较长的mp4，都被分拆出好几个duration 是有 8 min 的子文件了，在解决完压缩问题后，我们在看看要怎么把分拆过的视频合并起来。</p>
<h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p><code>ffmpeg -i &quot;concat:FD1-1.MP4|FD1-2.MP4|&quot; -c copy FD1-con.mp4</code></p>
<p>但是失败，结果还是只有FD1-1的内容，见有warning<br>Found duplicated MOOV Atom. Skipped it</p>
<p>输出只含有第一个文件的信息，我们再用方法2试下</p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><ol>
<li>创建一个文件 concatFile.txt，把需要合并的文件名称写进去：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file &apos;FD2-1.MP4&apos;</span><br><span class="line">file &apos;FD2-2.MP4&apos;</span><br><span class="line">file &apos;FD2-3.MP4&apos;</span><br><span class="line">file &apos;FD2-4.MP4&apos;</span><br><span class="line">file &apos;FD2-5.MP4&apos;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>执行</p>
<p><code>ffmpeg -f concat -i concatFile.txt -c copy fd2output.mp4</code></p>
</li>
</ol>
<p>查看输出结果 fd2output.mp4， 已成功合并了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习技术， 无非是为了解决实际问题，技术再好，境界越高，若未能落地应用，也是空中楼阁而已。这次能通过编码的方式来解决来源于生活的问题，有作为技术人的一种自豪感啊。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/23/study swift/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/09/23/study swift/" itemprop="url">
                  Swift 学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-23T17:16:50+08:00">
                2020-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="self-跟-Type-傻傻分不清"><a href="#self-跟-Type-傻傻分不清" class="headerlink" title=".self 跟 .Type 傻傻分不清"></a>.self 跟 .Type 傻傻分不清</h2><p>Int.Type 是 Int 的元类型()，而 Int.Type 跟 Int.self 的关系，就是 Int 跟 5 的关系，一个是类型，一个是值</p>
<h2 id="什么是元类型？"><a href="#什么是元类型？" class="headerlink" title="什么是元类型？"></a>什么是元类型？</h2><p>我们通过元类型，去调用这个类的 static 方法,个人感觉，有点像 oc 被类对象的 isa 指针所指向的 meta Class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Int.max</span><br><span class="line"></span><br><span class="line">//实际上等价于：</span><br><span class="line"></span><br><span class="line">Int.self.max</span><br><span class="line"></span><br><span class="line">//只是编译器帮我们省去了这个self</span><br></pre></td></tr></table></figure>
<h2 id="protocol-Type"><a href="#protocol-Type" class="headerlink" title="protocol.Type?"></a>protocol.Type?</h2><p>首先 protocol 不是一个类型，只有他被一个类实现了，才具有元类型这个说法</p>
<h2 id="show-me-the-code"><a href="#show-me-the-code" class="headerlink" title="show me the code"></a>show me the code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">protocol MYStrategy &#123;</span><br><span class="line">    func cal() -&gt; Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class PlanA : MYStrategy &#123;</span><br><span class="line">    required init() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    func cal() -&gt; Int &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class  PlanB : MYStrategy &#123;</span><br><span class="line">    required init() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    func cal() -&gt; Int &#123;</span><br><span class="line">        return 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct PlanFactory &#123;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">        根据类型推断，免去传参的烦恼</span><br><span class="line">     */</span><br><span class="line">    static func createPlan&lt;T: MYStrategy&gt;() -&gt; T? &#123;</span><br><span class="line">        if let planA = T.self as? PlanA.Type &#123;</span><br><span class="line">            return planA.init() as? T</span><br><span class="line">        &#125;</span><br><span class="line">        if let planB = T.self as? PlanB.Type &#123;</span><br><span class="line">            return planB.init() as? T</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">        type 传入的是一个元类型的值，由于 MYStrategy 是 protocol，这里传一个实现了 MYStrategy 的类的元类型的值即可</span><br><span class="line">     */</span><br><span class="line">    static func createPlanV2(type: MYStrategy.Type) -&gt; MYStrategy? &#123;</span><br><span class="line">        if type == PlanA.self &#123;</span><br><span class="line">            return PlanA()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if type == PlanB.self &#123;</span><br><span class="line">            return PlanB()</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MainTest &#123;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        var plan:PlanA? = PlanFactory.createPlan()</span><br><span class="line">        </span><br><span class="line">        var planT = PlanFactory.createPlanV2(type: PlanA.self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="type-of：-跟-self"><a href="#type-of：-跟-self" class="headerlink" title="type(of：) 跟 .self"></a>type(of：) 跟 .self</h2><p>相同点：都是获取 metaType (元类型)</p>
<p>不同点：<code>type(of: value)</code>, 其中参数value 是个对象实例，主要用于动态获取 value 的 元类型；而 XXX.self 是静态获取 XXX 的元类型，其中 XXX 是个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var testString = &quot;123&quot;</span><br><span class="line">var a = type(of: testString) //String</span><br><span class="line">var b = String.self     //String</span><br><span class="line">var c = testString.self // 123</span><br></pre></td></tr></table></figure>
<h2 id="Self"><a href="#Self" class="headerlink" title="Self"></a>Self</h2><p>在协议中用得比较多用来表示遵循这个协议的对象<br>这里用例子自定义命名空间的例子来说明一下（仿照rxSwift）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  这个 struct 作为命名空间 Xr </span><br><span class="line">  Base 是泛型</span><br><span class="line">*/</span><br><span class="line">public struct Xr&lt;Base&gt; &#123;</span><br><span class="line">    public let base: Base</span><br><span class="line">    public init(_ base: Base) &#123;</span><br><span class="line">        self.base = base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    协议 + 关联类型</span><br><span class="line">    一个静态 getter, 一个实例 getter</span><br><span class="line"> */</span><br><span class="line">public protocol XrCompatible &#123;</span><br><span class="line">    associatedtype XrBase</span><br><span class="line">    static var xr: Xr&lt;XrBase&gt;.Type &#123; get &#125;</span><br><span class="line">    var xr: Xr&lt;XrBase&gt; &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    扩展 XrCompatible，写默认实现</span><br><span class="line">    限定 Base 类型为 Self</span><br><span class="line"> */</span><br><span class="line">extension XrCompatible &#123;</span><br><span class="line">    </span><br><span class="line">    //这里的几个 Self， 是给 Xr 的&lt;Base&gt; 泛型做了限制，限制为遵循这个协议的对象本身</span><br><span class="line">    </span><br><span class="line">    //静态 xr getter,用于扩展类方法</span><br><span class="line">    public static var xr: Xr&lt;Self&gt;.Type &#123;</span><br><span class="line">        get &#123; Xr&lt;Self&gt;.self &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //实例 xr getter，用于扩展实例方法</span><br><span class="line">    public var xr: Xr&lt;Self&gt; &#123;</span><br><span class="line">        get &#123; Xr(self) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    赋予以下类 XrCompatible 的能力，可以直接用默认实现的两个 getter 来玩，让他们有了 XX.xr 的命名空间</span><br><span class="line"> */</span><br><span class="line">extension NSObject: XrCompatible &#123; &#125;</span><br><span class="line">extension String: XrCompatible &#123; &#125;</span><br><span class="line">extension Data: XrCompatible &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    对 Xr 且 base 是 String 类型的进行扩展，新增方法 appendHaha</span><br><span class="line"> */</span><br><span class="line">extension Xr where Base == String &#123;</span><br><span class="line">    func appendHaha() -&gt; String &#123;</span><br><span class="line">        return base+&quot;haha&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let testString = &quot;123&quot;.xr.appendHaha()</span><br><span class="line">// 123haha</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/30/mobX flutter 数据流动/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/06/30/mobX flutter 数据流动/" itemprop="url">
                  MobX Flutter 数据流动原理篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-30T17:23:17+08:00">
                2020-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>MoTouch 项目中的状态管理大部分是基于 MobX 的， 使用方法就不在这里说了，详见 <a href="https://mobx.netlify.app/getting-started" target="_blank" rel="noopener">MobX官网</a>。</p>
<p> 使用过的同学们都知道，当 Observer builder 里面某个 MobX 属性发生改变时，就会自动刷新 Observer 了。但我一直有个疑问，为什么数据不用进行显式的绑定，到底是在哪里进行绑定的？如何才能确定某个属性已经被正确监听了？带着这些疑问，我们一起学习下源码。</p>
<h1 id="类结构分工"><a href="#类结构分工" class="headerlink" title="类结构分工"></a>类结构分工</h1><h2 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h2><p>被观察对象<br>Atom 对象是由 xxx.g.dart 生成, 实际上，我们每标记一个 @observable 属性，在 .g.dart 生成 getter 跟 setter 及对应的 atom, 通过 <code>_atom.reportRead()</code> 和 <code>_atom.reportWrite()</code> 来触发 ReactiveContext 的数据绑定及分发。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:mobx/mobx.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">part</span> <span class="string">'counter.g.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> = <span class="title">_Counter</span> <span class="title">with</span> <span class="title">_</span>$<span class="title">Counter</span>; //外面实例化的是这个 <span class="title">Counter</span>， 实际上 是把<span class="title">_</span>$<span class="title">Counter</span> 这个 <span class="title">Mixin</span> 实例化了</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">abstract</span> <span class="title">class</span> <span class="title">_Counter</span> <span class="title">with</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="meta">@observable</span></span><br><span class="line">  <span class="built_in">int</span> value = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@observable</span></span><br><span class="line">	ObservableMap&lt;<span class="built_in">String</span>, Size&gt; uidVideoSizeMap = ObservableMap();</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@action</span></span><br><span class="line">  <span class="keyword">void</span> increment() &#123;</span><br><span class="line">    value++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">part</span> of <span class="string">'counter.dart'</span>;</span><br><span class="line"></span><br><span class="line">mixin _$Counter on _Counter, Store &#123;<span class="comment">// _$Counter 又继承了_Counter</span></span><br><span class="line">  <span class="keyword">final</span> _$valueAtom = Atom(name: <span class="string">'_Counter.value'</span>);</span><br><span class="line">  ···</span><br><span class="line">  <span class="keyword">final</span> _$uidVideoSizeMapAtom = Atom(name: <span class="string">'_Counter.uidVideoSizeMap'</span>);</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><h3 id="0-3-8"><a href="#0-3-8" class="headerlink" title="0.3.8"></a>0.3.8</h3><p>项目最早是用 0.3.8 版本的，很有印象，Observer 其核心就是个 StatefulWidget 而已，一旦数据变化，内部通过调用 setState(), 触发 State 的刷新，从而触发 builder 的刷新。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> invalidate() =&gt; setState(noOp);</span><br></pre></td></tr></table></figure>
<h3 id="1-1-0"><a href="#1-1-0" class="headerlink" title="1.1.0"></a>1.1.0</h3><p>而到了 1.1.0 版本，Observer 的实现就有所不同了，不再是个StatefulWidget, 而是个 StatelessWidget了。主角是 elemtent , 核心通过 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void invalidate() =&gt; markNeedsBuild();</span><br></pre></td></tr></table></figure>
<p>标记 当前 element 为 dirty, 在下一帧触发相应的 build 方法。</p>
<h2 id="Reaction（ReactionImpl，Derivation）"><a href="#Reaction（ReactionImpl，Derivation）" class="headerlink" title="Reaction（ReactionImpl，Derivation）"></a>Reaction（ReactionImpl，Derivation）</h2><p>被 Observer 持有，封装数据绑定，更新回调方法。Reaction.run 回调给 Observer</p>
<h2 id="ReactiveContext"><a href="#ReactiveContext" class="headerlink" title="ReactiveContext"></a>ReactiveContext</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final ReactiveContext mainContext = createContext(config: ReactiveConfig.main);</span><br></pre></td></tr></table></figure>
<p>是个巨大的单例，负责处理 Atom 跟 Reaction 的依赖关系, 及进行数据方法绑定、分发、解绑等逻辑。</p>
<h1 id="数据流动过程"><a href="#数据流动过程" class="headerlink" title="数据流动过程"></a>数据流动过程</h1><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p> 整个数据绑定过程，在 0.3.8 版本是发生在 Observer State 的 build 里面，而在 1.1.0 版本，是在 Observer Element 的 build 方法体内。</p>
<h3 id="1-start-tracking"><a href="#1-start-tracking" class="headerlink" title="1. start tracking"></a>1. start tracking</h3><p>在 ReactiveContext 单例记录当前的 derivation。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Derivation _startTracking(Derivation derivation) &#123;</span><br><span class="line">    <span class="keyword">final</span> prevDerivation = _state.trackingDerivation;</span><br><span class="line">    _state.trackingDerivation = derivation;</span><br><span class="line"></span><br><span class="line">    _resetDerivationState(derivation);</span><br><span class="line">    derivation._newObservables = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prevDerivation;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-reportObserved"><a href="#2-reportObserved" class="headerlink" title="2. reportObserved()"></a>2. reportObserved()</h3><p><img src="http://emyms.bs2dl.yy.com/MzIyMDhlMzgtMThmMy00YzQ2LTg0NDUtMWVkYmJjOGZiNzUx.png" alt="image-20200623114315072"></p>
<p>看堆栈可以知道，对于每一次 @Observable 对象的 get 调用，实际上是  <code>atom.reportObserved()</code> ，最终调用ReaciveContext 的 <code>_reportObserved</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _reportObserved(Atom atom) &#123;</span><br><span class="line">    <span class="keyword">final</span> derivation = _state.trackingDerivation; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (derivation != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 把 atom 加到当前的 derivation 的新观察队列里面</span></span><br><span class="line">      derivation._newObservables.add(atom);</span><br><span class="line">      <span class="keyword">if</span> (!atom._isBeingObserved) &#123;</span><br><span class="line">        atom</span><br><span class="line">          .._isBeingObserved = <span class="keyword">true</span></span><br><span class="line">          .._notifyOnBecomeObserved();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-endTracking"><a href="#3-endTracking" class="headerlink" title="3. endTracking"></a>3. endTracking</h3><p><img src="http://emyms.bs2dl.yy.com/ZDc5OGRkYjAtYWJlZC00OTZjLWJhZGQtNzlmYTZhNTdlYzQ1.png" alt="image-20200622143205460"></p>
<p>把在 startTracking 跟 endTracking  之间， 所有被调用  <code>reportRead()</code> 的 atom， 绑定当前观察者 derivation 。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _bindDependencies(Derivation derivation) &#123;</span><br><span class="line">  <span class="comment">// 这里对 Set 搞了两次difference， 目的是把新、旧 atoms 分开。旧的清空数据，新的绑定观察者</span></span><br><span class="line">  <span class="keyword">final</span> staleObservables =</span><br><span class="line">      derivation._observables.difference(derivation._newObservables);</span><br><span class="line">  <span class="keyword">final</span> newObservables =</span><br><span class="line">      derivation._newObservables.difference(derivation._observables);</span><br><span class="line">  <span class="keyword">var</span> lowestNewDerivationState = DerivationState.upToDate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add newly found observables</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> observable <span class="keyword">in</span> newObservables) &#123;</span><br><span class="line">    observable._addObserver(derivation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Computed = Observable + Derivation</span></span><br><span class="line">    <span class="keyword">if</span> (observable <span class="keyword">is</span> Computed) &#123;</span><br><span class="line">      <span class="keyword">if</span> (observable._dependenciesState.index &gt;</span><br><span class="line">          lowestNewDerivationState.index) &#123;</span><br><span class="line">        lowestNewDerivationState = observable._dependenciesState;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove previous observables</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> ob <span class="keyword">in</span> staleObservables) &#123;</span><br><span class="line">    ob._removeObserver(derivation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lowestNewDerivationState != DerivationState.upToDate) &#123;</span><br><span class="line">    derivation</span><br><span class="line">      .._dependenciesState = lowestNewDerivationState</span><br><span class="line">      .._onBecomeStale();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  derivation</span><br><span class="line">    .._observables = derivation._newObservables</span><br><span class="line">    .._newObservables = &#123;&#125;; <span class="comment">// No need for newObservables beyond this point</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="reportWrite"><a href="#reportWrite" class="headerlink" title="reportWrite()"></a>reportWrite()</h3><p>当数据更新 atom.reportWrite() 主要做了这两件事：</p>
<ol>
<li>更新 数据</li>
<li>把 与之绑定 derivation (即 reaction) 加到队列。</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> reportWrite&lt;T&gt;(T newValue, T oldValue, <span class="keyword">void</span> <span class="built_in">Function</span>() setNewValue) &#123;</span><br><span class="line">  context.spyReport(ObservableValueSpyEvent(<span class="keyword">this</span>,</span><br><span class="line">      newValue: newValue, oldValue: oldValue, name: name));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ignore: cascade_invocations</span></span><br><span class="line">  context.conditionallyRunInAction(() &#123;</span><br><span class="line">    setNewValue();</span><br><span class="line">    reportChanged();<span class="comment">//触发 Context.addPendingReaction(reaction)</span></span><br><span class="line">  &#125;, <span class="keyword">this</span>, name: <span class="string">'<span class="subst">$&#123;name&#125;</span>_set'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ignore: cascade_invocations</span></span><br><span class="line">  context.spyReport(EndedSpyEvent(type: <span class="string">'observable'</span>, name: name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把 reaction 添加到队列, 这里 reaction 就是 ReactionImpl</span></span><br><span class="line"><span class="keyword">void</span> addPendingReaction(Reaction reaction) &#123;</span><br><span class="line">  _state.pendingReactions.add(reaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据分发"><a href="#数据分发" class="headerlink" title="数据分发"></a>数据分发</h2><h3 id="action"><a href="#action" class="headerlink" title="@action"></a>@action</h3><p><img src="http://emyms.bs2dl.yy.com/YTc1ZmY4MzAtMjk3Yy00MzA2LTkyZDctMjY2NDhmMmUzMDg2.png" alt="image-20200622151359216"></p>
<h3 id="不带-action"><a href="#不带-action" class="headerlink" title="不带 @action"></a>不带 @action</h3><p><img src="http://emyms.bs2dl.yy.com/NjM4ZWQ0MjgtOTc1My00ZGE5LTgyZDYtMDUwZjFlODI3ZjNh.png" alt="image-20200622152046571"></p>
<p>带不带 @action 的区别，其实就是 下面这个地方有没把 <code>ActionController</code> 传入来，数据流向其实是一样的，都会由 <code>controller.endAction(runInfo);</code> 来触发。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> conditionallyRunInAction(<span class="keyword">void</span> <span class="built_in">Function</span>() fn, Atom atom,</span><br><span class="line">    &#123;<span class="built_in">String</span> name, ActionController actionController&#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isWithinBatch) &#123;</span><br><span class="line">    enforceWritePolicy(atom);</span><br><span class="line">    fn();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> controller = actionController ??</span><br><span class="line">        ActionController(</span><br><span class="line">            context: <span class="keyword">this</span>, name: name ?? nameFor(<span class="string">'conditionallyRunInAction'</span>));</span><br><span class="line">    <span class="keyword">final</span> runInfo = controller.startAction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      enforceWritePolicy(atom);</span><br><span class="line">      fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      controller.endAction(runInfo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _runReactionsInternal() &#123;</span><br><span class="line">  _state.isRunningReactions = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从队列读取 reaction</span></span><br><span class="line">  <span class="keyword">var</span> iterations = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> allReactions = _state.pendingReactions;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (allReactions.isNotEmpty) &#123;</span><br><span class="line">    <span class="comment">// 这里是抛出死循环的情况</span></span><br><span class="line">    <span class="keyword">if</span> (++iterations == config.maxIterations) &#123;</span><br><span class="line">      <span class="keyword">final</span> failingReaction = allReactions[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Resetting ensures we have no bad-state left</span></span><br><span class="line">      _resetState();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">throw</span> MobXCyclicReactionException(</span><br><span class="line">          <span class="string">"Reaction doesn't converge to a stable state after <span class="subst">$&#123;config.maxIterations&#125;</span> iterations. Probably there is a cycle in the reactive function: $failingReaction"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> remainingReactions = allReactions.toList(growable: <span class="keyword">false</span>);</span><br><span class="line">    allReactions.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> reaction <span class="keyword">in</span> remainingReactions) &#123;</span><br><span class="line">      reaction._run();<span class="comment">//分发，回调给 Observer 层</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _state</span><br><span class="line">    ..pendingReactions = []</span><br><span class="line">    ..isRunningReactions = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最终触发-rebuild"><a href="#最终触发-rebuild" class="headerlink" title="最终触发 rebuild"></a>最终触发 rebuild</h3><h4 id="0-3-8-1"><a href="#0-3-8-1" class="headerlink" title="0.3.8"></a>0.3.8</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//observer.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Observer</span>&gt; </span>&#123;</span><br><span class="line">		<span class="keyword">void</span> invalidate() =&gt; setState(noOp);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-0-1"><a href="#1-1-0-1" class="headerlink" title="1.1.0"></a>1.1.0</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//observer_widget_mixin.dart</span></span><br><span class="line">	mixin ObserverElementMixin on ComponentElement &#123;</span><br><span class="line">	<span class="comment">//reaction.run 回调给 Observer 层，通过 markNeedsBuild 触发 rebuild</span></span><br><span class="line">	<span class="keyword">void</span> invalidate() =&gt; markNeedsBuild();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h2><p>因为 MobX 里面存在一个 ReactiveContext 单例，那就涉及到对数据的清除绑定了</p>
<p><img src="http://emyms.bs2dl.yy.com/MWFkZmY0YWMtNzM1OS00ZTVlLTk1YzUtMzA4NDBhMjU2ZWQz.png" alt="image-20200622164901647"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void _clearObservables(Derivation derivation) &#123;</span><br><span class="line">    final observables = derivation._observables;</span><br><span class="line">    derivation._observables = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    for (final x in observables) &#123;</span><br><span class="line">    //打破 atom 跟 reaction 的双向依赖</span><br><span class="line">      x._removeObserver(derivation);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    derivation._dependenciesState = DerivationState.notTracking;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>在实际开发过程中，我们项目会遇到一些数据更新了，但没触发 Observer rebuild 的一些疑问，在弄清楚数据流向后，现在可以基本解决了。</p>
<p><code>Counter</code> 还是用上文那个例子,我们这次是对其中MobX 提供的 <code>ObservableMap</code> 进行监听，意图监听 map 的增减操作。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_mobx/flutter_mobx.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:mobx/mobx.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:motouch/UI/Me/counter.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterExample</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> CounterExample();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  CounterExampleState createState() =&gt; CounterExampleState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterExampleState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CounterExample</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Counter counter = Counter();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          backgroundColor: Colors.blue,</span><br><span class="line">          title: <span class="keyword">const</span> Text(<span class="string">'MobX Counter'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Column(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Observer(</span><br><span class="line">                builder: (_) &#123;</span><br><span class="line">                  <span class="comment">//bind 1</span></span><br><span class="line">                  counter.uidVideoSizeMap;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//bind 2</span></span><br><span class="line"><span class="comment">//                  counter.uidVideoSizeMap.length;</span></span><br><span class="line">                  </span><br><span class="line">                  <span class="built_in">print</span>(<span class="string">'rebuild'</span>);</span><br><span class="line">                  <span class="keyword">return</span> Container();</span><br><span class="line">                &#125;,</span><br><span class="line">              ),</span><br><span class="line">              MaterialButton(</span><br><span class="line">                child: Text(<span class="string">'对 counter.uidVideoSizeMap 重新赋值'</span>),</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  <span class="comment">//update 1</span></span><br><span class="line">                  <span class="built_in">print</span>(<span class="string">'对 counter.uidVideoSizeMap 重新赋值'</span>);</span><br><span class="line">                  counter.uidVideoSizeMap = ObservableMap();</span><br><span class="line">                &#125;,</span><br><span class="line">              ),</span><br><span class="line">              MaterialButton(</span><br><span class="line">                child: Text(<span class="string">'counter.uidVideoSizeMap 增减元素'</span>),</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  <span class="comment">//update 2</span></span><br><span class="line">                  <span class="built_in">print</span>(<span class="string">'counter.uidVideoSizeMap 增减元素'</span>);</span><br><span class="line">                  counter.uidVideoSizeMap[<span class="string">'1'</span>] = Size.zero;</span><br><span class="line">                &#125;,</span><br><span class="line">              ),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分绑定分2种方式，我们先注释 bind 2，用 <code>counter.uidVideoSizeMap</code>绑定，看看打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (20534): 对 counter.uidVideoSizeMap 重新赋值</span><br><span class="line">I/flutter (20534): rebuild</span><br><span class="line">I/flutter (20534): 对 counter.uidVideoSizeMap 重新赋值</span><br><span class="line">I/flutter (20534): rebuild</span><br><span class="line">I/flutter (20534): 对 counter.uidVideoSizeMap 重新赋值</span><br><span class="line">I/flutter (20534): rebuild</span><br><span class="line">I/flutter (20534): counter.uidVideoSizeMap 增减元素</span><br><span class="line">I/flutter (20534): counter.uidVideoSizeMap 增减元素</span><br></pre></td></tr></table></figure>
<p>可见，bind 1 这种方式，增减元素是不会引起 Observer 的 rebuild 的。</p>
<p>再来看看注释 bind 1, 打开 <code>counter.uidVideoSizeMap.length</code>的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (20534): 对 counter.uidVideoSizeMap 重新赋值</span><br><span class="line">I/flutter (20534): rebuild</span><br><span class="line">I/flutter (20534): 对 counter.uidVideoSizeMap 重新赋值</span><br><span class="line">I/flutter (20534): rebuild</span><br><span class="line">I/flutter (20534): counter.uidVideoSizeMap 增减元素</span><br><span class="line">I/flutter (20534): rebuild</span><br><span class="line">I/flutter (20534): counter.uidVideoSizeMap 增减元素</span><br></pre></td></tr></table></figure>
<p>bind 2 的方式，无论是重新赋值，还是增减元素，都能引起 Observer 的 rebuild 。</p>
<p>结合源码来分析，bind 1这种绑定方式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//counter.g.dart</span></span><br><span class="line"><span class="comment">// 在 Observer builder 方法体内，每次 counter.uidVideoSizeMap, 触发的是 _Counter.uidVideoSizeMap 这个属性 atom 的 reportRead()， 绑定的是这个属性本身，跟 ObserverMap 的类型无关。</span></span><br><span class="line">  <span class="keyword">final</span> _$uidVideoSizeMapAtom = Atom(name: <span class="string">'_Counter.uidVideoSizeMap'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ObservableMap&lt;<span class="built_in">String</span>, Size&gt; <span class="keyword">get</span> uidVideoSizeMap &#123;</span><br><span class="line">    _$uidVideoSizeMapAtom.reportRead();<span class="comment">//内里调用 reportObserver()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.uidVideoSizeMap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>bind 2:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//observable_map.dart </span></span><br><span class="line"><span class="comment">// 在 Observer builder 方法体内，调用 counter.uidVideoSizeMap.length，是把 Observer_map 里面实现 的 _atom 给绑定了。</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> length &#123;</span><br><span class="line">    _context.enforceReadPolicy(_atom);</span><br><span class="line"></span><br><span class="line">    _atom.reportObserved();<span class="comment">//绑定</span></span><br><span class="line">    <span class="keyword">return</span> _map.length;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可见， bind 1, bind 2两种绑定方式，决定了 reaction 的不同， bind 1 那种方式完全把 uidVideoSizeMap 当成普通类型来用了，压根没有把 <code>ObservableMap</code> 类型带给我们便利给用上。</p>
<p><code>ObservableList</code>, <code>ObservableSet</code> 也同理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/thunder 黑屏/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/03/03/thunder 黑屏/" itemprop="url">
                  Flutter 实战系列： 记一次视频区域黑屏问题分析与解决
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-03T21:34:02+08:00">
                2020-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>咱们 MoTouch 项目中的直播间内的视频区域是通过 flutter platform view  + Thunder SDK 实现的，而在开发和测试过程中，iOS 侧频频出现莫名其妙的黑屏问题，而且是整个远端视图都黑了，分析日志后，发现： thunder 的远端流通知跟远端视图的首帧回调到来了，但视频区域还是黑的，怀疑是由于业务层调用接口不恰当引起的，这里记录一下问题的分析和解决。</p>
<h2 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h2><h3 id="哪里黑屏了"><a href="#哪里黑屏了" class="headerlink" title="哪里黑屏了"></a>哪里黑屏了</h3><p>既然 thunder 那边首帧回调都过来了，大概率是业务层这边的不恰当处理了···第一反应是这个这个 platform view 到底有没加上视图？ frame 到底对不对？<br>等在 debug 复现黑屏情况后，在 xcode 看过视图层级，发现这个时候的 frame，size 都没问题，后来还是在 SDK 的同学帮忙排查下，才发现，是在调用 FlutterThunder.setRemoteVideoLayout 的时候，view 的 frame 是 0，导致 sdk 这个 video 的 frame 是 0 了，即使后来  view 的 frame 对了，但是没更新到 FlutterThunder 那边。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Widget _remoteMixinWidget() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_remoteViewWidget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    _remoteViewWidget = FlutterThunder.createNativeView((viewId) &#123;</span><br><span class="line">      remoteViewId = viewId;</span><br><span class="line">      FlutterThunder.setRemoteVideoLayout(...)<span class="comment">// 这句调用时机不对， platform view 的 frame 还是 0</span></span><br><span class="line">    &#125;, key: _remoteKey);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _remoteViewWidget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="frame-为啥是-0-？"><a href="#frame-为啥是-0-？" class="headerlink" title="frame 为啥是 0 ？"></a>frame 为啥是 0 ？</h3><p>翻翻 engine 的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//FlutterPlatformViews.mm</span><br><span class="line"></span><br><span class="line">void FlutterPlatformViewsController::OnCreate(FlutterMethodCall* call, FlutterResult&amp; result) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  NSObject&lt;FlutterPlatformView&gt;* embedded_view = [factory createWithFrame:CGRectZero</span><br><span class="line">                                                           viewIdentifier:viewId</span><br><span class="line">                                                                arguments:params];// 这个 CGRectZero 是engine 自己塞的</span><br><span class="line">  views_[viewId] = fml::scoped_nsobject&lt;NSObject&lt;FlutterPlatformView&gt;&gt;([embedded_view retain]);</span><br><span class="line"></span><br><span class="line">  FlutterTouchInterceptingView* touch_interceptor = [[[FlutterTouchInterceptingView alloc]</span><br><span class="line">                  initWithEmbeddedView:embedded_view.view</span><br><span class="line">                 flutterViewController:flutter_view_controller_.get()</span><br><span class="line">      gestureRecognizersBlockingPolicy:gesture_recognizers_blocking_policies[viewType]]</span><br><span class="line">      autorelease];// 塞进 FlutterTouchInterceptingView</span><br><span class="line"></span><br><span class="line">  touch_interceptors_[viewId] =</span><br><span class="line">      fml::scoped_nsobject&lt;FlutterTouchInterceptingView&gt;([touch_interceptor retain]);</span><br><span class="line">  root_views_[viewId] = fml::scoped_nsobject&lt;UIView&gt;([touch_interceptor retain]);</span><br><span class="line"></span><br><span class="line">  result(nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见 platform view 初始化出来时，肯定是 CGRectZero 的。</p>
<p>但什么时候才是正确的呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithEmbeddedView:(UIView*)embeddedView</span><br><span class="line">               flutterViewController:(UIViewController*)flutterViewController</span><br><span class="line">    gestureRecognizersBlockingPolicy:</span><br><span class="line">        (FlutterPlatformViewGestureRecognizersBlockingPolicy)blockingPolicy &#123;</span><br><span class="line">  self = [super initWithFrame:embeddedView.frame];</span><br><span class="line">  if (self) &#123;</span><br><span class="line">    self.multipleTouchEnabled = YES;</span><br><span class="line">    embeddedView.autoresizingMask =</span><br><span class="line">        (UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight);</span><br><span class="line"></span><br><span class="line">    [self addSubview:embeddedView];</span><br><span class="line"></span><br><span class="line">    ForwardingGestureRecognizer* forwardingRecognizer =</span><br><span class="line">        [[[ForwardingGestureRecognizer alloc] initWithTarget:self</span><br><span class="line">                                       flutterViewController:flutterViewController] autorelease];</span><br><span class="line"></span><br><span class="line">    _delayingRecognizer.reset([[DelayingGestureRecognizer alloc]</span><br><span class="line">              initWithTarget:self</span><br><span class="line">                      action:nil</span><br><span class="line">        forwardingRecognizer:forwardingRecognizer]);</span><br><span class="line">    _blockingPolicy = blockingPolicy;</span><br><span class="line"></span><br><span class="line">    [self addGestureRecognizer:_delayingRecognizer.get()];</span><br><span class="line">    [self addGestureRecognizer:forwardingRecognizer];</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们都看得出来， FlutterPlatformView 实际上是被一个 FlutterTouchInterceptingView 包住的，其 frame 是跟随 FlutterTouchInterceptingView 大小</p>
<p>所以，我们顺藤摸瓜，看看 FlutterTouchInterceptingView 的 frame 到底在哪里改正确的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FlutterPlatformViewsController::CompositeWithParams(<span class="keyword">int</span> view_id,</span><br><span class="line">                                                         <span class="keyword">const</span> EmbeddedViewParams&amp; params) &#123;</span><br><span class="line">  <span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, params.sizePoints.width(), params.sizePoints.height());</span><br><span class="line">  <span class="built_in">UIView</span>* touchInterceptor = touch_interceptors_[view_id].get();</span><br><span class="line">  touchInterceptor.layer.transform = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">  touchInterceptor.frame = frame; <span class="comment">// 就是这里了</span></span><br><span class="line">  touchInterceptor.alpha = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="addPostFrameCallback"><a href="#addPostFrameCallback" class="headerlink" title="addPostFrameCallback?"></a>addPostFrameCallback?</h3><p>讲真，我们在 flutter 层其实对 native 的 frame 操作基本上是没有了，来看下我们都是怎么设置 platformView 的大小跟坐标的</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Widget remoteView() &#123;</span><br><span class="line">    <span class="keyword">return</span> Positioned(</span><br><span class="line">      top: <span class="number">0</span>,</span><br><span class="line">      left: <span class="number">0</span>,</span><br><span class="line">      child: Container(</span><br><span class="line">        color: Colors.black,</span><br><span class="line">        width: <span class="number">100</span>,</span><br><span class="line">        height: <span class="number">100</span>,</span><br><span class="line">        child: remoteMixinView,<span class="comment">//platformview</span></span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容易看出来，通过对 platform view 的 父亲节点（Container 之类）设置坐标宽高，让其跟随父亲节点的大小。</p>
<p>那这个 platform view 的 宽高跟坐标在 flutter 层什么时候才确定呢？</p>
<p>google 一下，  建议是在这个每帧回调里面打印：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WidgetsBinding.instance.addPostFrameCallback((_) &#123;</span><br><span class="line">          RenderBox renderBox = _key.currentContext.findRenderObject();</span><br><span class="line">          <span class="built_in">print</span>(</span><br><span class="line">              <span class="string">'<span class="subst">$&#123;renderBox.size&#125;</span>, <span class="subst">$&#123;renderBox.localToGlobal(Offset.zero)&#125;</span>'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个 WidgetsBinding 相当于连接 engine 跟 widget layer 的桥梁，而 postFrameCallBack 是在每一帧渲染后，回调执行的。</p>
<p>那这个 addPostFrameCallback 回调是否靠谱，我们得通过源码分析看看。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="要点复习"><a href="#要点复习" class="headerlink" title="要点复习"></a>要点复习</h3><p>既然涉及 .mm 跟 dart 的交互，我们先来看看 c++ 跟 dart 层是如何交互的：</p>
<h4 id="C-（Engine）-与-dart-Framework-交互"><a href="#C-（Engine）-与-dart-Framework-交互" class="headerlink" title="C ++（Engine） 与 dart (Framework) 交互"></a>C ++（Engine） 与 dart (Framework) 交互</h4><p>主要集中在这几个文件里面：window.dart, window.cc，hooks.dart</p>
<h5 id="dart-调用-c"><a href="#dart-调用-c" class="headerlink" title="dart 调用 c++"></a>dart 调用 c++</h5><p>window.cc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//注册 native 方法</span><br><span class="line">void Window::RegisterNatives(tonic::DartLibraryNatives* natives) &#123;</span><br><span class="line">  natives-&gt;Register(&#123;</span><br><span class="line">      &#123;&quot;Window_defaultRouteName&quot;, DefaultRouteName, 1, true&#125;,</span><br><span class="line">      &#123;&quot;Window_scheduleFrame&quot;, ScheduleFrame, 1, true&#125;,</span><br><span class="line">      &#123;&quot;Window_sendPlatformMessage&quot;, _SendPlatformMessage, 4, true&#125;,</span><br><span class="line">      &#123;&quot;Window_respondToPlatformMessage&quot;, _RespondToPlatformMessage, 3, true&#125;,</span><br><span class="line">      &#123;&quot;Window_render&quot;, Render, 2, true&#125;,</span><br><span class="line">      &#123;&quot;Window_updateSemantics&quot;, UpdateSemantics, 2, true&#125;,</span><br><span class="line">      &#123;&quot;Window_setIsolateDebugName&quot;, SetIsolateDebugName, 2, true&#125;,</span><br><span class="line">      &#123;&quot;Window_reportUnhandledException&quot;, ReportUnhandledException, 2, true&#125;,</span><br><span class="line">      &#123;&quot;Window_setNeedsReportTimings&quot;, SetNeedsReportTimings, 2, true&#125;,</span><br><span class="line">      &#123;&quot;Window_getPersistentIsolateData&quot;, GetPersistentIsolateData, 1, true&#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">void Render(Dart_NativeArguments args) &#123;</span><br><span class="line">  Dart_Handle exception = nullptr;</span><br><span class="line">  Scene* scene =</span><br><span class="line">      tonic::DartConverter&lt;Scene*&gt;::FromArguments(args, 1, exception);</span><br><span class="line">  if (exception) &#123;</span><br><span class="line">    Dart_ThrowException(exception);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  UIDartState::Current()-&gt;window()-&gt;client()-&gt;Render(scene);//这个 clinet() 实际是 engine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>window.dart<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void render(Scene scene) native &apos;Window_render&apos;;//实际上是调用 window.cc 的native 方法</span><br></pre></td></tr></table></figure></p>
<h5 id="c-调用-dart"><a href="#c-调用-dart" class="headerlink" title="c++ 调用 dart"></a>c++ 调用 dart</h5><p>hooks.dart</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pragma</span>(<span class="string">'vm:entry-point'</span>)</span><br><span class="line"><span class="comment">// ignore: unused_element</span></span><br><span class="line"><span class="keyword">void</span> _drawFrame() &#123;</span><br><span class="line">  _invoke(<span class="built_in">window</span>.onDrawFrame, <span class="built_in">window</span>._onDrawFrameZone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>window.dart</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VoidCallback get onDrawFrame =&gt; _onDrawFrame;</span><br></pre></td></tr></table></figure>
<p><img src="http://emyms.bs2dl.yy.com/YjM4M2E4ZDEtZTI0Yy00NjFkLTliNWYtYmVlZDZmYTczZTRl.jpg" alt="image-20200321233237397"></p>
<h3 id="相关交互流程"><a href="#相关交互流程" class="headerlink" title="相关交互流程"></a>相关交互流程</h3><p>整个渲染流程有点长，这里简要用白话总结下跟本文相关的几个交互步骤：</p>
<ol>
<li><p>Engine 层监听 Vsync 信号，通过 _drawFrame 告诉 framework 层，快准备好数据给我（Flutter::layer tree）</p>
</li>
<li><p>Framework 层在 window.onBeginFrame ， window.onDrawFrame 接收 Engine 的信息，把 widgets 的 UI 配置信息转化为 Layer, 最终产物是个 LayerTree ,通过 render() 发送个回 Engine</p>
</li>
<li><p>Engine 在 GPU 线程 处理 LayerTree,  主要通过 rasterizer 做栅格化操作（ 将 LayerTree 转化为 SkCanvas） </p>
</li>
<li><p>略····</p>
<p>更详细的交互流程可以看这位大神的 blog: <a href="http://gityuan.com/2019/06/15/flutter_ui_draw/" target="_blank" rel="noopener">http://gityuan.com/2019/06/15/flutter_ui_draw/</a></p>
</li>
</ol>
<p>   我们写界面实际上是不用接触到 Layer 的， 是 Framework 层做了转换，看下图，Container 对应的 flutter::ContainerLayer，PlatformView 对应 flutter::PlatformViewLayer， 他们都继承于 Flutter::layer。</p>
<p>   <img src="http://emyms.bs2dl.yy.com/MjYyMzBmMDktOGUwZS00YTBjLWFiNDMtYzNjMzhjMjkxODI5.jpg" alt="image-20200322154209908"></p>
<p>   <a href="https://engine.chinmaygarde.com/classflutter_1_1_layer.html" target="_blank" rel="noopener">https://engine.chinmaygarde.com/classflutter_1_1_layer.html</a></p>
<p>源码看到 PlatformViewLayer 这一层，其实离答案已经不远了。</p>
<h3 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h3><p>我们一起来看看 postFrameCallback 在被调用前究竟发生了什么？</p>
<p><img src="http://emyms.bs2dl.yy.com/ZWJkZTBmOTEtNWJiOC00MDY5LWFlMGUtOWZjZWJiM2ZmYjVi.jpg" alt="image-20200322154209908"></p>
<p>是先遍历执行了 _persistentCallbacks， 其中主角是下面的 drawFrame()，然后再遍历执行 postFrameCallback</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">///rendering/binding.dart</span><br><span class="line"></span><br><span class="line">  @protected</span><br><span class="line">  void drawFrame() &#123;</span><br><span class="line">    assert(renderView != null);</span><br><span class="line">    pipelineOwner.flushLayout();</span><br><span class="line">    pipelineOwner.flushCompositingBits();</span><br><span class="line">    pipelineOwner.flushPaint();</span><br><span class="line">    renderView.compositeFrame(); // this sends the bits to the GPU</span><br><span class="line">    pipelineOwner.flushSemantics(); // this also sends the semantics to the OS.</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中由  <code>renderView.compositeFrame();</code>触发， 通过 _window.render 把相关信息 由dart 层  widget ui 数据回传给 engine C++ 层：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void compositeFrame() &#123;</span><br><span class="line">   ...</span><br><span class="line">    _window.render(scene); //这里调用 window.dart 的 render(Scene scene)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Animator.cc</span><br><span class="line">void Animator::Render(std::unique_ptr&lt;flutter::LayerTree&gt; layer_tree) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//这个代理实际上是  shell.cc</span><br><span class="line">  delegate_.OnAnimatorDraw(layer_tree_pipeline_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里开始，已经转到 GPU 线程了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">///shell.cc</span><br><span class="line">// |Animator::Delegate|</span><br><span class="line">void Shell::OnAnimatorDraw(fml::RefPtr&lt;Pipeline&lt;flutter::LayerTree&gt;&gt; pipeline) &#123;</span><br><span class="line">  FML_DCHECK(is_setup_);</span><br><span class="line"></span><br><span class="line">  task_runners_.GetGPUTaskRunner()-&gt;PostTask(//切换线程</span><br><span class="line">      [&amp; waiting_for_first_frame = waiting_for_first_frame_,</span><br><span class="line">       &amp;waiting_for_first_frame_condition = waiting_for_first_frame_condition_,</span><br><span class="line">       rasterizer = rasterizer_-&gt;GetWeakPtr(),</span><br><span class="line">       pipeline = std::move(pipeline)]() &#123;</span><br><span class="line">        if (rasterizer) &#123;</span><br><span class="line">          rasterizer-&gt;Draw(pipeline);</span><br><span class="line"></span><br><span class="line">          if (waiting_for_first_frame.load()) &#123;</span><br><span class="line">            waiting_for_first_frame.store(false);</span><br><span class="line">            waiting_for_first_frame_condition.notify_all();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">///Rasterizer.cc</span><br><span class="line">void Rasterizer::Draw(fml::RefPtr&lt;Pipeline&lt;flutter::LayerTree&gt;&gt; pipeline) &#123;</span><br><span class="line">  TRACE_EVENT0(&quot;flutter&quot;, &quot;GPURasterizer::Draw&quot;);</span><br><span class="line">  if (gpu_thread_merger_ &amp;&amp; !gpu_thread_merger_-&gt;IsOnRasterizingThread()) &#123;</span><br><span class="line">    // we yield and let this frame be serviced on the right thread.</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  FML_DCHECK(task_runners_.GetGPUTaskRunner()-&gt;RunsTasksOnCurrentThread());</span><br><span class="line"></span><br><span class="line">  RasterStatus raster_status = RasterStatus::kFailed;</span><br><span class="line">  Pipeline&lt;flutter::LayerTree&gt;::Consumer consumer =</span><br><span class="line">      [&amp;](std::unique_ptr&lt;LayerTree&gt; layer_tree) &#123;</span><br><span class="line">        raster_status = DoDraw(std::move(layer_tree));</span><br><span class="line">      &#125;;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">RasterStatus Rasterizer::DoDraw(</span><br><span class="line">    std::unique_ptr&lt;flutter::LayerTree&gt; layer_tree) &#123;</span><br><span class="line">  FML_DCHECK(task_runners_.GetGPUTaskRunner()-&gt;RunsTasksOnCurrentThread());</span><br><span class="line"></span><br><span class="line">  if (!layer_tree || !surface_) &#123;</span><br><span class="line">    return RasterStatus::kFailed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FrameTiming timing;</span><br><span class="line">  timing.Set(FrameTiming::kBuildStart, layer_tree-&gt;build_start());</span><br><span class="line">  timing.Set(FrameTiming::kBuildFinish, layer_tree-&gt;build_finish());</span><br><span class="line">  timing.Set(FrameTiming::kRasterStart, fml::TimePoint::Now());</span><br><span class="line"></span><br><span class="line">  PersistentCache* persistent_cache = PersistentCache::GetCacheForProcess();</span><br><span class="line">  persistent_cache-&gt;ResetStoredNewShaders();</span><br><span class="line"></span><br><span class="line">  RasterStatus raster_status = DrawToSurface(*layer_tree);</span><br><span class="line">  if (raster_status == RasterStatus::kSuccess) &#123;</span><br><span class="line">    last_layer_tree_ = std::move(layer_tree);</span><br><span class="line">  &#125; else if (raster_status == RasterStatus::kResubmit) &#123;</span><br><span class="line">    resubmitted_layer_tree_ = std::move(layer_tree);</span><br><span class="line">    return raster_status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  return raster_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RasterStatus Rasterizer::DrawToSurface(flutter::LayerTree&amp; layer_tree) &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (compositor_frame) &#123;</span><br><span class="line">    RasterStatus raster_status = compositor_frame-&gt;Raster(layer_tree, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///compositor_context.cc</span></span><br><span class="line">RasterStatus CompositorContext::ScopedFrame::Raster(</span><br><span class="line">    flutter::LayerTree&amp; layer_tree,</span><br><span class="line">    <span class="keyword">bool</span> ignore_raster_cache) &#123;</span><br><span class="line">  TRACE_EVENT0(<span class="string">"flutter"</span>, <span class="string">"CompositorContext::ScopedFrame::Raster"</span>);</span><br><span class="line">  <span class="keyword">bool</span> root_needs_readback = layer_tree.Preroll(*<span class="keyword">this</span>, ignore_raster_cache);</span><br><span class="line">  <span class="keyword">bool</span> needs_save_layer = root_needs_readback &amp;&amp; !surface_supports_readback();</span><br><span class="line">  PostPrerollResult post_preroll_result = PostPrerollResult::kSuccess;</span><br><span class="line">  <span class="keyword">if</span> (view_embedder_ &amp;&amp; gpu_thread_merger_) &#123;</span><br><span class="line">    post_preroll_result = view_embedder_-&gt;PostPrerollAction(gpu_thread_merger_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (post_preroll_result == PostPrerollResult::kResubmitFrame) &#123;</span><br><span class="line">    <span class="keyword">return</span> RasterStatus::kResubmit;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Clearing canvas after preroll reduces one render target switch when preroll</span></span><br><span class="line">  <span class="comment">// paints some raster cache.</span></span><br><span class="line">  <span class="keyword">if</span> (canvas()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (needs_save_layer) &#123;</span><br><span class="line">      FML_LOG(INFO) &lt;&lt; <span class="string">"Using SaveLayer to protect non-readback surface"</span>;</span><br><span class="line">      SkRect bounds = SkRect::Make(layer_tree.frame_size());</span><br><span class="line">      SkPaint paint;</span><br><span class="line">      paint.setBlendMode(SkBlendMode::kSrc);</span><br><span class="line">      canvas()-&gt;saveLayer(&amp;bounds, &amp;paint);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas()-&gt;clear(SK_ColorTRANSPARENT);</span><br><span class="line">  &#125;</span><br><span class="line">  layer_tree.Paint(*<span class="keyword">this</span>, ignore_raster_cache); <span class="comment">// 这句是重点</span></span><br><span class="line">  <span class="keyword">if</span> (canvas() &amp;&amp; needs_save_layer) &#123;</span><br><span class="line">    canvas()-&gt;restore();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> RasterStatus::kSuccess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">///layer_tree.cc</span><br><span class="line">void LayerTree::Paint(CompositorContext::ScopedFrame&amp; frame,</span><br><span class="line">                      bool ignore_raster_cache) const &#123;</span><br><span class="line">  TRACE_EVENT0(&quot;flutter&quot;, &quot;LayerTree::Paint&quot;);</span><br><span class="line"></span><br><span class="line">  if (!root_layer_) &#123;</span><br><span class="line">    FML_LOG(ERROR) &lt;&lt; &quot;The scene did not specify any layers to paint.&quot;;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SkISize canvas_size = frame.canvas()-&gt;getBaseLayerSize();</span><br><span class="line">  SkNWayCanvas internal_nodes_canvas(canvas_size.width(), canvas_size.height());</span><br><span class="line">  internal_nodes_canvas.addCanvas(frame.canvas());</span><br><span class="line">  if (frame.view_embedder() != nullptr) &#123;</span><br><span class="line">    auto overlay_canvases = frame.view_embedder()-&gt;GetCurrentCanvases();</span><br><span class="line">    for (size_t i = 0; i &lt; overlay_canvases.size(); i++) &#123;</span><br><span class="line">      internal_nodes_canvas.addCanvas(overlay_canvases[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Layer::PaintContext context = &#123;</span><br><span class="line">      (SkCanvas*)&amp;internal_nodes_canvas,</span><br><span class="line">      frame.canvas(),</span><br><span class="line">      frame.gr_context(),</span><br><span class="line">      frame.view_embedder(),</span><br><span class="line">      frame.context().raster_time(),</span><br><span class="line">      frame.context().ui_time(),</span><br><span class="line">      frame.context().texture_registry(),</span><br><span class="line">      ignore_raster_cache ? nullptr : &amp;frame.context().raster_cache(),</span><br><span class="line">      checkerboard_offscreen_layers_,</span><br><span class="line">      frame_physical_depth_,</span><br><span class="line">      frame_device_pixel_ratio_&#125;;</span><br><span class="line"></span><br><span class="line">  if (root_layer_-&gt;needs_painting())</span><br><span class="line">    root_layer_-&gt;Paint(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 PlatformViewLayer 继承于 flutter::Layer ， 我们聚焦在 PlatformViewLayer</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///Platform_view_layer.cc</span></span><br><span class="line"><span class="keyword">void</span> PlatformViewLayer::Paint(PaintContext&amp; context) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (context.view_embedder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    FML_LOG(ERROR) &lt;&lt; <span class="string">"Trying to embed a platform view but the PaintContext "</span></span><br><span class="line">                      <span class="string">"does not support embedding"</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  SkCanvas* canvas = context.view_embedder-&gt;CompositeEmbeddedView(view_id_);</span><br><span class="line">  context.leaf_nodes_canvas = canvas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///FlutterPlatformviews.mm</span></span><br><span class="line">SkCanvas* FlutterPlatformViewsController::CompositeEmbeddedView(<span class="keyword">int</span> view_id) &#123;</span><br><span class="line">  <span class="comment">// TODO(amirh): assert that this is running on the platform thread once we support the iOS</span></span><br><span class="line">  <span class="comment">// embedded views thread configuration.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do nothing if the view doesn't need to be composited.</span></span><br><span class="line">  <span class="keyword">if</span> (views_to_recomposite_.count(view_id) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> picture_recorders_[view_id]-&gt;getRecordingCanvas();</span><br><span class="line">  &#125;</span><br><span class="line">  CompositeWithParams(view_id, current_composition_params_[view_id]);<span class="comment">//**</span></span><br><span class="line">  views_to_recomposite_.erase(view_id);</span><br><span class="line">  <span class="keyword">return</span> picture_recorders_[view_id]-&gt;getRecordingCanvas();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后终于回到这里 setFrame </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void FlutterPlatformViewsController::CompositeWithParams(int view_id,</span><br><span class="line">                                                         const EmbeddedViewParams&amp; params) &#123;</span><br><span class="line">  CGRect frame = CGRectMake(0, 0, params.sizePoints.width(), params.sizePoints.height());</span><br><span class="line">  UIView* touchInterceptor = touch_interceptors_[view_id].get();</span><br><span class="line">  touchInterceptor.layer.transform = CATransform3DIdentity;</span><br><span class="line">  touchInterceptor.frame = frame; // 就是这里了</span><br><span class="line">  touchInterceptor.alpha = 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>纵观整个调用流程，其中涉及到 由 UI 线程（dart ）切换到 gpu 线程，其中最后的 setFrame 也是在 gpu 线程执行的，而 postFrameCallback 回调是在 dart 层，所以 postFrameCallback 跟 setFrame 并不是在同一个线程，即使按顺序执行下来，setFrame 也不一定比 postFrameCallback 回调执行前先发生。</p>
<p>那 addPostFrameCallback 是不是也就不能解决这个 frame 为 0 的问题了？</p>
<h3 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h3><p>我们都知道， dart 层只有一个线程，而在 engine 层，就不一样了：</p>
<p>当 IsIosEmbeddedViewsPreviewEnabled 为 true 时，</p>
<p> platform  跟 gpu 共用一个线程，且为主线程</p>
<p>i/o 操作独用一个线程</p>
<p>Ui 即 dart 层独用另外一个线程;</p>
<p>其他情况，platform、gpu、i/o, ui 各用一个线程</p>
<p>更多 engine 线程 相关的知识，可以参考这里：<a href="https://zhuanlan.zhihu.com/p/38026271" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38026271</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">///FlutterEngine.mm</span><br><span class="line">if (flutter::IsIosEmbeddedViewsPreviewEnabled()) &#123;</span><br><span class="line"></span><br><span class="line">  flutter::TaskRunners task_runners(threadLabel.UTF8String,                          // label</span><br><span class="line">                                    fml::MessageLoop::GetCurrent().GetTaskRunner(),  // platform</span><br><span class="line">                                    fml::MessageLoop::GetCurrent().GetTaskRunner(),  // gpu</span><br><span class="line">                                    _threadHost.ui_thread-&gt;GetTaskRunner(),          // ui</span><br><span class="line">                                    _threadHost.io_thread-&gt;GetTaskRunner()           // io</span><br><span class="line">  );</span><br><span class="line">  // Create the shell. This is a blocking operation.</span><br><span class="line">  _shell = flutter::Shell::Create(std::move(task_runners),  // task runners</span><br><span class="line">                                  std::move(windowData),    // window data</span><br><span class="line">                                  std::move(settings),      // settings</span><br><span class="line">                                  on_create_platform_view,  // platform view creation</span><br><span class="line">                                  on_create_rasterizer      // rasterzier creation</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> platform  跟 gpu 共用一个线程意味着啥？</p>
<p>意味着，在 addPostFrameCallback 内只要执行的 platform channel 的方法，都可以保证在 setFrame 后再执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WidgetsBinding.instance.addPostFrameCallback((_) &#123;</span><br><span class="line">   FlutterThunder.setRemoteVideoLayout(...);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>兜了一圈，最终的解决方案就是把 frame 相关的代码调用放在 addPostFrameCallback 里面</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Widget _remoteMixinWidget() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_remoteViewWidget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    _remoteViewWidget = FlutterThunder.createNativeView((viewId) &#123;</span><br><span class="line">      remoteViewId = viewId;</span><br><span class="line">      WidgetsBinding.instance.addPostFrameCallback((_) &#123;</span><br><span class="line">         FlutterThunder.setRemoteVideoLayout(...);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, key: _remoteKey);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _remoteViewWidget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终流程如图所示：</p>
<p><img src="http://emyms.bs2dl.yy.com/NTczYmY4NjEtNzRhYS00M2YxLTk4NTMtNzBhODhlMDJkMWQ0.jpg" alt="未命名文件 (5)"></p>
<p>参考：</p>
<blockquote>
<p><a href="https://juejin.im/post/5e6b5b11f265da57187c64bd" target="_blank" rel="noopener">https://juejin.im/post/5e6b5b11f265da57187c64bd</a></p>
<p><a href="https://juejin.im/post/5c24acd5f265da6164141236" target="_blank" rel="noopener">https://juejin.im/post/5c24acd5f265da6164141236</a></p>
<p><a href="http://gityuan.com/2019/06/15/flutter_ui_draw/" target="_blank" rel="noopener">http://gityuan.com/2019/06/15/flutter_ui_draw/</a>   </p>
<p><a href="https://zhuanlan.zhihu.com/p/38026271" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38026271</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/13/physics/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/11/13/physics/" itemprop="url">
                  Flutter 实战系列:个性化 ListView physics
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-13T17:29:00+08:00">
                2019-11-13
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于这篇总结是产品需求驱动的，先简要描述下 Sofanovel 项目的需求：仿照 inkitt 首页，实现个带有 hover 效果的横向列表，我们先直接来看下最后实现效果：<br><img src="http://emyms.bs2dl.yy.com/YjQyYTE4MjUtNzQ2OS00ZWQ3LTlhNGMtNmVkZmY0ZGU2Y2Fm.gif" alt="![](http://emyms.bs2dl.yy.com/MmQzM2UyOTctYjZmMy00NTA5LWE2OTktMzViYmJjNzY1NzM0.gif)![](http://emyms.bs2dl.yy.com/MmQzM2UyOTctYjZmMy00NTA5LWE2OTktMzViYmJjNzY1NzM0.gif)"></p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>这个需求在 iOS 原生的 UIKIt 下 很好解决的，UIScrollView 本来就有个 paging 的属性，来实现这个 “翻页” 效果。而 Flutter 也有个类似的控件 PageView， 我们先来看下 PageView 的实现:</p>
<h3 id="PageView"><a href="#PageView" class="headerlink" title="PageView"></a>PageView</h3><p>普通的 PageView 实现是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">return Container(</span><br><span class="line">  height: 200,</span><br><span class="line">  width: 200,</span><br><span class="line">  child: PageView(</span><br><span class="line">    children: TestDatas.map((color) &#123;</span><br><span class="line">      return Container(</span><br><span class="line">        width: 100,</span><br><span class="line">        height: 200,</span><br><span class="line">        color: color,</span><br><span class="line">      );</span><br><span class="line">    &#125;).toList(),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>效果是 width 永远不受控制，充满屏幕，如图：<br><img src="http://emyms.bs2dl.yy.com/OGQwYjRkZjAtNTMwMy00ZGQwLWEwODQtNTAzMzI1MGU1MTRm.gif" alt></p>
<p>另一种实现：<br>加上 PageController 的 viewportFraction 修饰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">return Container(</span><br><span class="line">  height: 200,</span><br><span class="line">  child: PageView(</span><br><span class="line">    controller: PageController(initialPage: 0, viewportFraction: 0.8),</span><br><span class="line">    children: TestDatas.map((color) &#123;</span><br><span class="line">      return Container(</span><br><span class="line">        width: 100,</span><br><span class="line">        height: 200,</span><br><span class="line">        color: color,</span><br><span class="line">      );</span><br><span class="line">    &#125;).toList(),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>实现效果是这个样子的：<br><img src="http://emyms.bs2dl.yy.com/MmQzM2UyOTctYjZmMy00NTA5LWE2OTktMzViYmJjNzY1NzM0.gif" alt></p>
<p>viewportFraction 这个参数只能粗略地表示 选中区域 占屏幕的百分比，而这个区域永远落在中央，不能简单实现偏左或者偏右的自定义化，因此舍弃了 pageView 的实现。</p>
<h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><h4 id="赋予翻页效果"><a href="#赋予翻页效果" class="headerlink" title="赋予翻页效果"></a>赋予翻页效果</h4><p>从横向布局的 ListView 入手开搞，自定义一个带有 pageView 特性的 physics </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">class PagingScrollPhysics extends ScrollPhysics &#123;</span><br><span class="line">  final double itemDimension; // ListView children item 固定宽度</span><br><span class="line">  final double leadingSpacing; // 选中 item 离左边缘留白</span><br><span class="line">  final double maxSize; // 最大可滑动区域</span><br><span class="line"></span><br><span class="line">  PagingScrollPhysics(</span><br><span class="line">      &#123;this.maxSize,</span><br><span class="line">      this.leadingSpacing,</span><br><span class="line">      this.itemDimension,</span><br><span class="line">      ScrollPhysics parent&#125;)</span><br><span class="line">      : super(parent: parent);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  PagingScrollPhysics applyTo(ScrollPhysics ancestor) &#123;</span><br><span class="line">    return PagingScrollPhysics(</span><br><span class="line">        maxSize: maxSize,</span><br><span class="line">        itemDimension: itemDimension,</span><br><span class="line">        leadingSpacing: leadingSpacing,</span><br><span class="line">        parent: buildParent(ancestor));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  double _getPage(ScrollPosition position, double leading) &#123;</span><br><span class="line">    return (position.pixels + leading) / itemDimension;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  double _getPixels(double page, double leading) &#123;</span><br><span class="line">    return (page * itemDimension) - leading;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  double _getTargetPixels(</span><br><span class="line">    ScrollPosition position,</span><br><span class="line">    Tolerance tolerance,</span><br><span class="line">    double velocity,</span><br><span class="line">    double leading,</span><br><span class="line">  ) &#123;</span><br><span class="line">    double page = _getPage(position, leading);</span><br><span class="line"></span><br><span class="line">    if (position.pixels &lt; 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (position.pixels &gt;= maxSize) &#123;</span><br><span class="line">      return maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (position.pixels &gt; 0) &#123;</span><br><span class="line">      if (velocity &lt; -tolerance.velocity) &#123;</span><br><span class="line">        page -= 0.5;</span><br><span class="line">      &#125; else if (velocity &gt; tolerance.velocity) &#123;</span><br><span class="line">        page += 0.5;</span><br><span class="line">      &#125;</span><br><span class="line">      return _getPixels(page.roundToDouble(), leading);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Simulation createBallisticSimulation(</span><br><span class="line">      ScrollMetrics position, double velocity) &#123;</span><br><span class="line">    // If we&apos;re out of range and not headed back in range, defer to the parent</span><br><span class="line">    // ballistics, which should put us back in range at a page boundary.</span><br><span class="line"></span><br><span class="line">    if ((velocity &lt;= 0.0 &amp;&amp; position.pixels &lt;= position.minScrollExtent))</span><br><span class="line">      return super.createBallisticSimulation(position, velocity);</span><br><span class="line"></span><br><span class="line">    final Tolerance tolerance = this.tolerance;</span><br><span class="line"></span><br><span class="line">    final double target =</span><br><span class="line">        _getTargetPixels(position, tolerance, velocity, leadingSpacing);</span><br><span class="line">    if (target != position.pixels)</span><br><span class="line">      return ScrollSpringSimulation(spring, position.pixels, target, velocity,</span><br><span class="line">          tolerance: tolerance);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool get allowImplicitScrolling =&gt; false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码一大堆，我们聚焦入口 createBallisticSimulation ，这是每次滑动手势结束后会触发，最终都是为了调用下面这句，来产生滑动效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ScrollSpringSimulation(spring, position.pixels, target, velocity,</span><br><span class="line">    tolerance: tolerance);</span><br></pre></td></tr></table></figure>
<p>target 这个参数是整个类的主角，其他辅助函数都是为了计算出这个值而已，target 是表示这次滑动的终点，也就是说，我们通过控制这个参数来控制这次触摸结束后，listview 停在哪里。</p>
<p>其次，构造方法里面里面的 parent 参数也是挺重要的，主要用来组合各种 physics 属性，这里留在后面再说。</p>
<h4 id="选中动效"><a href="#选中动效" class="headerlink" title="选中动效"></a>选中动效</h4><p>这一步无非就是用 scrollView 监听 scroll offset,  到了指定位置就 setState ，已触发选中效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_scrollCtl.addListener(() &#123;</span><br><span class="line">  double test =</span><br><span class="line">      _bookWidth != null ? _scrollCtl.offset / (_bookWidth + margin) : 1;</span><br><span class="line">  int next = test.round();</span><br><span class="line">  if (next &lt; 0) &#123;</span><br><span class="line">    next = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (next &gt;= testData.length) &#123;</span><br><span class="line">    next = testData.length - 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (_currentPage != next) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _currentPage = next;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">_buildBookItem(Map data, bool active, &#123;num width&#125;) &#123;</span><br><span class="line">  width = _bookWidth;</span><br><span class="line">  // Animated Properties</span><br><span class="line">  final double blur = active ? 5 : 0;</span><br><span class="line">  final double offset = active ? 2 : 0;</span><br><span class="line">  final double top = active ? 10 : 20;</span><br><span class="line">  final double bottom = active ? 10 : 20;</span><br><span class="line"></span><br><span class="line">  return GestureDetector(</span><br><span class="line">    onTap: () &#123;</span><br><span class="line">      if (data[&apos;index&apos;] == _currentPage) &#123;</span><br><span class="line">        _jump();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        scrollToPage(data[&apos;index&apos;]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    child: AnimatedContainer(</span><br><span class="line">      width: width,</span><br><span class="line">      height: 1.38 * width,</span><br><span class="line">      child: Center(child: Text(data[&apos;index&apos;].toString())),</span><br><span class="line">      duration: Duration(milliseconds: 500),</span><br><span class="line">      curve: Curves.easeOutQuint,</span><br><span class="line">      margin: EdgeInsets.only(top: top, bottom: bottom, right: margin),</span><br><span class="line">      decoration: BoxDecoration(</span><br><span class="line">          borderRadius: BorderRadius.circular(4),</span><br><span class="line">          color: randomColor,</span><br><span class="line">          boxShadow: [</span><br><span class="line">            BoxShadow(</span><br><span class="line">                color: Colors.black87,</span><br><span class="line">                blurRadius: blur,</span><br><span class="line">                offset: Offset(offset, offset))</span><br><span class="line">          ]),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>在自测时发现过这样一个问题：当 listView 里面的 children  过少时， 整个 listView 压根不能滑动， physics 里面的 createBallisticSimulation 实现得再完美，也触发不了其中的回调的。为了避免这种情况，比较粗暴的方法是，在 children 加空白 Container，以充满 listView 固有的宽度或者高度，来让 listView 满足可滑动的前提。</p>
<h3 id="正规军解法"><a href="#正规军解法" class="headerlink" title="正规军解法"></a>正规军解法</h3><p>为何 chidren 过少就滑动不了？这里要看下 ScrollPhysics 的源码了，里面有这样一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/// Whether the scrollable should let the user adjust the scroll offset, for</span><br><span class="line">/// example by dragging.</span><br><span class="line">///</span><br><span class="line">/// By default, the user can manipulate the scroll offset if, and only if,</span><br><span class="line">/// there is actually content outside the viewport to reveal.</span><br><span class="line">///</span><br><span class="line">/// The given `position` is only valid during this method call. Do not keep a</span><br><span class="line">/// reference to it to use later, as the values may update, may not update, or</span><br><span class="line">/// may update to reflect an entirely unrelated scrollable.</span><br><span class="line">bool shouldAcceptUserOffset(ScrollMetrics position) &#123;</span><br><span class="line">  if (parent == null)</span><br><span class="line">    return position.pixels != 0.0 || position.minScrollExtent != position.maxScrollExtent;</span><br><span class="line">  return parent.shouldAcceptUserOffset(position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>源码里面注释得很清楚了，唯有内容超出显示范围时，才可以触发他的滚动，即 position.minScrollExtent != position.maxScrollExtent 的时候。<br>所以，我们重载一下这个方法就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">bool shouldAcceptUserOffset(ScrollMetrics position) =&gt; true;</span><br></pre></td></tr></table></figure>
<p>另外，也可以通过构造方法 parent 这个入参去组合多个的已有的 physics 来完成这种特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_physics = PagingScrollPhysics(</span><br><span class="line">        itemDimension: itemWidth,</span><br><span class="line">        leadingSpacing: _leadingPortion,</span><br><span class="line">        maxSize: itemWidth * (testData.length - 1) - _leadingPortion,</span><br><span class="line">        parent: BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics()));</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/Flutter-Overlay/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/07/28/Flutter-Overlay/" itemprop="url">
                  Flutter实战系列: 实现顶级视图可拖动悬浮窗
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-28T15:35:01+08:00">
                2019-07-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><p>这个需求有两个关键点：</p>
<ol>
<li>顶级视图</li>
<li>可拖动</li>
</ol>
<h3 id="涉及-Widget-知识点"><a href="#涉及-Widget-知识点" class="headerlink" title="涉及 Widget 知识点"></a>涉及 Widget 知识点</h3><ol>
<li>Overlay，顶级视图解决方案</li>
<li>Draggable，可拖动解决方案</li>
</ol>
<h4 id="Overlay"><a href="#Overlay" class="headerlink" title="Overlay"></a>Overlay</h4><p>Overlay 之于 Flutter , 有点相当于 KeyWindow 之于 iOS 一样，可以将子 widget 置于其他 widget 的顶层，带来 “悬浮”的效果，具体可见注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// A [Stack] of entries that can be managed independently.</span><br><span class="line">///</span><br><span class="line">/// Overlays let independent child widgets &quot;float&quot; visual elements on top of</span><br><span class="line">/// other widgets by inserting them into the overlay&apos;s [Stack]. The overlay lets</span><br><span class="line">/// each of these widgets manage their participation in the overlay using</span><br><span class="line">/// [OverlayEntry] objects.</span><br><span class="line">/// Rather than creating an overlay, consider using the overlay that is</span><br><span class="line">/// created by the [WidgetsApp] or the [MaterialApp] for the application.</span><br></pre></td></tr></table></figure></p>
<p>文档不建议我们重新初始化一个 overlay 对象 , 最好还是通过 <code>Overlay.of(context)</code>，这样的方式去获取已经存在的 <code>Overlay</code> 对象。</p>
<p>这里就又引出了另外一个新概念 <em>OverlayEntry</em></p>
<h4 id="OverlayEntry"><a href="#OverlayEntry" class="headerlink" title="OverlayEntry"></a>OverlayEntry</h4><p><code>OverlayEntry</code> 之于 <code>Overlay</code>，对于 iOS 开发而言，又有点 subView 之于 KeyWindow 的味道了。 <code>OverlayEntry</code> 是视图的实际的容器， 把其往 <code>Overlay</code> 那儿添加了，就可以成像了。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Creates an overlay entry.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// To insert the entry into an [Overlay], first find the overlay using</span></span><br><span class="line"><span class="comment">/// [Overlay.of] and then call [OverlayState.insert]. To remove the entry,</span></span><br><span class="line"><span class="comment">/// call [remove] on the overlay entry itself.</span></span><br><span class="line">OverlayEntry(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.builder, 		<span class="comment">// builder 模式返回一个 widget</span></span><br><span class="line">    <span class="built_in">bool</span> opaque = <span class="keyword">false</span>,    		<span class="comment">// 是否不透明</span></span><br><span class="line">    <span class="built_in">bool</span> maintainState = <span class="keyword">false</span>,	<span class="comment">// 这个属性与 opaque 有关系，如果某个 entry A的 opaque 被设成 true 了， 那么 overlay 就不去 build 其他在层级在 entry A 以下的 entry 了， 除非 maintainState 设成 true</span></span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(builder != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(opaque != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(maintainState != <span class="keyword">null</span>),</span><br><span class="line">       _opaque = opaque,</span><br><span class="line">       _maintainState = maintainState;</span><br></pre></td></tr></table></figure>
<h4 id="Draggable"><a href="#Draggable" class="headerlink" title="Draggable"></a>Draggable</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const Draggable(&#123;</span><br><span class="line"> Key key,</span><br><span class="line"> @required this.child,				// 初始化显示的 widget</span><br><span class="line"> @required this.feedback,		// 拖拽过程中（活动中）显示的 widget</span><br><span class="line"> this.data,									// widget 携带的数据，放手时可以将这个 data 数据传递出去</span><br><span class="line"> this.axis,									// 限制 draggable 的移动范围</span><br><span class="line"> this.childWhenDragging,			// 拖住动作发生过程中，初始化位置显示的 widget</span><br><span class="line"> this.feedbackOffset = Offset.zero, // 当 feedback 与 child 相比，有 transform 的时候，需要用到这个属性来调整 hittest 范围</span><br><span class="line"> this.dragAnchor = DragAnchor.child, //锚点</span><br><span class="line"> this.affinity,							// 单词的意思是亲和力，当 Draggable 位于 另外一个 Scrollable 控件內时，来控制到底这个这个拖拽事件到底由 Draggable 响应，还是由 Scrollable 控件来响应</span><br><span class="line"> this.maxSimultaneousDrags,	// 限制有多少个 Draggable 同时发生 拖拽动作</span><br><span class="line"> this.onDragStarted,					// 拖拽动作开始回调</span><br><span class="line"> this.onDraggableCanceled,		// 拖拽动作取消回调</span><br><span class="line"> this.onDragEnd,							//拖拽动作结束回调</span><br><span class="line"> this.onDragCompleted,				// 拖拽动作完成回调, 并被一个 DragTarget 接收</span><br><span class="line"> this.ignoringFeedbackSemantics = true, // 也是看了文档才知道，这个属性还是有点用的，当 feedback 跟 child 是同一个 widget A 对象时，就应该把这个属性设成 false, 配合赋值一个 GlobalKey，这样，这个 widget A 就不会在 feedback 跟 child 切换时，重新销毁后又创建了。这个在 widget A 带有播放动画是比较容易看出区别，每次手指拖放都伴随着动画的重新开始</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>一开始只留意到 <code>feedback</code>， <code>childWhenDragging</code>， <code>onDragEnd</code> 几个参数，实际上 <code>ignoringFeedbackSemantics</code> 也是挺重要的，这个放在后面再说。</p>
<p>把我们想要实现拖拽功能的 widget 传到 child 参数位置的时候，跑一下，可以发现，我们已经实现了拖拽功能了，但这个时候，当我们手指离开屏幕的话，child 又自动回到了初始化的位置了，并没有停留在我们想要他停留的位置，为了实现这个功能，我们又得用到另外一个 widget : <code>DragTarget</code></p>
<h4 id="DragTarget"><a href="#DragTarget" class="headerlink" title="DragTarget"></a>DragTarget</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const DragTarget(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  @required this.builder,  //根据 Draggable 传过来的 data ,来显示想要的 widget</span><br><span class="line">  this.onWillAccept,			// 根据传过来的 data ,选择是否接收这个 Draggable， 返回 true 则激活 onAccept</span><br><span class="line">  this.onAccept,					// Draggable 被丢进了这个 DragTarget 区域后回调</span><br><span class="line">  this.onLeave,						// Draggable 离开 DragTarget 区域后的回调</span><br><span class="line">&#125;) : super(key: key);</span><br></pre></td></tr></table></figure>
<p>DragTarget 是用来作为 Draggable 被拖拽结束后接收他的区域,  当然 他可以通过 onWillAccept 的 data ,来选择 接不接收这个 Draggable 。</p>
<p>好了，前面搬文档说了一大堆废话，下面，我们来将这个几个 widget 组合运用起来，实现文章一开始的需求。</p>
<h3 id="组合起来"><a href="#组合起来" class="headerlink" title="组合起来"></a>组合起来</h3><p>关键代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void show(&#123;@required BuildContext context, @required Widget view&#125;) &#123;</span><br><span class="line">  TestOverLay.view = view;</span><br><span class="line"></span><br><span class="line">	//避免重复 show</span><br><span class="line">  remove();</span><br><span class="line">  </span><br><span class="line">  //创建一个OverlayEntry对象</span><br><span class="line">  OverlayEntry overlayEntry = new OverlayEntry(builder: (context) &#123;</span><br><span class="line">  	//通过 Positioned 控制 位置</span><br><span class="line">    return new Positioned(</span><br><span class="line">        top: MediaQuery.of(context).size.height * 0.7,</span><br><span class="line">        child: _buildDraggable(context));</span><br><span class="line">  	&#125;);</span><br><span class="line"></span><br><span class="line">  //往当前 Overlay 中插入 OverlayEntry</span><br><span class="line">  Overlay.of(context).insert(overlayEntry);</span><br><span class="line"></span><br><span class="line">  _holder = overlayEntry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> show 方法无非做了 2 件事：</p>
<ol>
<li>_buildDraggable </li>
<li>创建 OverlayEntry， 并插入到当前上下文的 Overlay</li>
</ol>
<p>再看下 _buildDraggable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static _buildDraggable(context) &#123;</span><br><span class="line">  return new Draggable(</span><br><span class="line">    child: view,										//  child 跟 feedback 用传入同一个 view，这样初始化跟拖拽过程都显示这个 view</span><br><span class="line">    feedback: view,									//</span><br><span class="line">    onDragStarted: () &#123;</span><br><span class="line">       print(&apos;onDragStarted:&apos;);</span><br><span class="line">     &#125;,</span><br><span class="line">	onDragEnd: (detail) &#123;</span><br><span class="line">      print(&apos;onDragEnd:$&#123;detail.offset&#125;&apos;);</span><br><span class="line">      createDragTarget(offset: detail.offset, context: context); // 放手的时候创建一个DragTarget</span><br><span class="line">    &#125;,</span><br><span class="line">    childWhenDragging: Container(), //  这里传个 Container，原来位置啥都不显示</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>放手的时候创建一个 DragTarget对象，用来接收 Draggable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static void createDragTarget(&#123;Offset offset, BuildContext context&#125;) &#123;</span><br><span class="line">  if (_holder != null) &#123;</span><br><span class="line">    _holder.remove();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _holder = new OverlayEntry(builder: (context) &#123;</span><br><span class="line">    bool isLeft = true;</span><br><span class="line">    if (offset.dx + 100 &gt; MediaQuery.of(context).size.width / 2) &#123;</span><br><span class="line">      isLeft = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double maxY = MediaQuery.of(context).size.height - 100;</span><br><span class="line"></span><br><span class="line">    return new Positioned(</span><br><span class="line">        top: offset.dy &lt; 50 ? 50 : offset.dy &lt; maxY ? offset.dy : maxY,</span><br><span class="line">        left: isLeft ? 0 : null,</span><br><span class="line">        right: isLeft ? null : 0,</span><br><span class="line">        child: DragTarget(</span><br><span class="line">          onWillAccept: (data) &#123;</span><br><span class="line">            print(&apos;onWillAccept: $data&apos;);</span><br><span class="line">            return true;</span><br><span class="line">          &#125;,</span><br><span class="line">          onAccept: (data) &#123;</span><br><span class="line">            holded = true;</span><br><span class="line">            print(&apos;onAccept: $data&apos;);</span><br><span class="line">            // refresh();</span><br><span class="line">          &#125;,</span><br><span class="line">          onLeave: (data) &#123;</span><br><span class="line">            print(&apos;onLeave&apos;);</span><br><span class="line">          &#125;,</span><br><span class="line">          builder: (BuildContext context, List incoming, List rejected) &#123;</span><br><span class="line">            return _buildDraggable(context);</span><br><span class="line">          &#125;,</span><br><span class="line">        ));</span><br><span class="line">  &#125;);</span><br><span class="line">  Overlay.of(context).insert(_holder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里也是通过 Positioned 来给 DragTarget 指定位置的，需求对 Draggable 携带的 data 不关心，来者不拒，所以 onWillAccept 那儿直接 return true了；</p>
<p>当接收了 Draggable 后，在 builder 返回想要显示的内容，这里，我们直接返回之前那个 Draggable 对象好了，为下次的拖拽做好准备。</p>
<p>到此为止，整个流程就结束了。</p>
<p>这里看下初步实现效果：<br><img src="/2019/07/28/Flutter-Overlay/image-1564461044-优化前.gif" title="优化前动效"></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>细心的同学可以很容易会发现，每次拖拽动作的开始，结束的时候，view 的旋转动画都会被重置，体验并不友好。看了下日志就知道，在这两个时刻, 都会触发 view 的重建和销毁：</p>
<img src="/2019/07/28/Flutter-Overlay/image-1564461001-优化前log.png" title="优化后log">
<h4 id="ignoringFeedbackSemantics"><a href="#ignoringFeedbackSemantics" class="headerlink" title="ignoringFeedbackSemantics"></a>ignoringFeedbackSemantics</h4><p>文档提示我们，当 <code>Draggable</code> 的 <code>child</code>跟<code>feedback</code>相同时， <code>ignoringFeedbackSemantics = false</code> ，与 <code>GlobalKey</code> 配合使用，可以让 <code>feedback</code> 在 <code>child</code> 切换时，所对应 widget 不被 销毁 和 重新创建，这样设置后，再看下日志</p>
<img src="/2019/07/28/Flutter-Overlay/image-1564461147-优化后log.png" title="优化后log">
<p><code>onDragStated</code>,<code>onDragEnd</code>,虽然也触发了 <code>MiniRoomFloatingWidget</code> 的 <code>build</code> 方法，但并没有销毁及重创建。</p>
<p>在来看下优化后的效果：</p>
<img src="/2019/07/28/Flutter-Overlay/image-1564461330-优化后.gif" title="优化后动效">
<h3 id="最后附上代码"><a href="#最后附上代码" class="headerlink" title="最后附上代码"></a>最后附上代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">class TestOverLay &#123;</span><br><span class="line">  static OverlayEntry _holder;</span><br><span class="line"></span><br><span class="line">  static Widget view;</span><br><span class="line"></span><br><span class="line">  static void remove() &#123;</span><br><span class="line">    if (_holder != null) &#123;</span><br><span class="line">      _holder.remove();</span><br><span class="line">      _holder = null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void show(&#123;@required BuildContext context, @required Widget view&#125;) &#123;</span><br><span class="line">    TestOverLay.view = view;</span><br><span class="line"></span><br><span class="line">    remove();</span><br><span class="line">    //创建一个OverlayEntry对象</span><br><span class="line">    OverlayEntry overlayEntry = new OverlayEntry(builder: (context) &#123;</span><br><span class="line">      return new Positioned(</span><br><span class="line">          top: MediaQuery.of(context).size.height * 0.7,</span><br><span class="line">          child: _buildDraggable(context));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //往Overlay中插入插入OverlayEntry</span><br><span class="line">    Overlay.of(context).insert(overlayEntry);</span><br><span class="line"></span><br><span class="line">    _holder = overlayEntry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static _buildDraggable(context) &#123;</span><br><span class="line">    return new Draggable(</span><br><span class="line">      child: view,</span><br><span class="line">      feedback: view,</span><br><span class="line">      onDragStarted: ()&#123;</span><br><span class="line">        print(&apos;onDragStarted:&apos;);</span><br><span class="line">      &#125;,</span><br><span class="line">      onDragEnd: (detail) &#123;</span><br><span class="line">        print(&apos;onDragEnd:$&#123;detail.offset&#125;&apos;);</span><br><span class="line">        createDragTarget(offset: detail.offset, context: context);</span><br><span class="line">      &#125;,</span><br><span class="line">      childWhenDragging: Container(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void refresh() &#123;</span><br><span class="line">    _holder.markNeedsBuild();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void createDragTarget(&#123;Offset offset, BuildContext context&#125;) &#123;</span><br><span class="line">    if (_holder != null) &#123;</span><br><span class="line">      _holder.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _holder = new OverlayEntry(builder: (context) &#123;</span><br><span class="line">      bool isLeft = true;</span><br><span class="line">      if (offset.dx + 100 &gt; MediaQuery.of(context).size.width / 2) &#123;</span><br><span class="line">        isLeft = false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      double maxY = MediaQuery.of(context).size.height - 100;</span><br><span class="line"></span><br><span class="line">      return new Positioned(</span><br><span class="line">          top: offset.dy &lt; 50 ? 50 : offset.dy &lt; maxY ? offset.dy : maxY,</span><br><span class="line">          left: isLeft ? 0 : null,</span><br><span class="line">          right: isLeft ? null : 0,</span><br><span class="line">          child: DragTarget(</span><br><span class="line">            onWillAccept: (data) &#123;</span><br><span class="line">              print(&apos;onWillAccept: $data&apos;);</span><br><span class="line">              return true;</span><br><span class="line">            &#125;,</span><br><span class="line">            onAccept: (data) &#123;</span><br><span class="line">              print(&apos;onAccept: $data&apos;);</span><br><span class="line">              // refresh();</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave: (data) &#123;</span><br><span class="line">              print(&apos;onLeave&apos;);</span><br><span class="line">            &#125;,</span><br><span class="line">            builder: (BuildContext context, List incoming, List rejected) &#123;</span><br><span class="line">              return _buildDraggable(context);</span><br><span class="line">            &#125;,</span><br><span class="line">          ));</span><br><span class="line">    &#125;);</span><br><span class="line">    Overlay.of(context).insert(_holder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p><a href="https://medium.com/flutter-community/a-deep-dive-into-draggable-and-dragtarget-in-flutter-487919f6f1e4" target="_blank" rel="noopener">https://medium.com/flutter-community/a-deep-dive-into-draggable-and-dragtarget-in-flutter-487919f6f1e4</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/24/Flutter-tabBar一定要居中吗？/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/06/24/Flutter-tabBar一定要居中吗？/" itemprop="url">
                  Flutter: tabBar一定要居中吗？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-24T10:18:05+08:00">
                2019-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><p>flutter 的 tabbar 都是这个样子居中的，<br><img src="/2019/06/24/Flutter-tabBar一定要居中吗？/image-20190624114534451.png" title="充满整行"></p>
<p>能不能不居中呢？<br>一开始对了下那 tabbar api 中的几个属性，</p>
<pre><code>const TabBar({
Key key,
@required this.tabs,
this.controller,
this.isScrollable = false,
this.indicatorColor,
this.indicatorWeight = 2.0,
this.indicatorPadding = EdgeInsets.zero,
this.indicator,
this.indicatorSize,
this.labelColor,
this.labelStyle,
this.labelPadding,
this.unselectedLabelColor,
this.unselectedLabelStyle,
this.dragStartBehavior = DragStartBehavior.start,
this.onTap,}
) 
</code></pre><p>发现通过设置属性是不能达到预想效果，于是，弱弱地走去了人家官网提了个 issue， <a href="https://github.com/flutter/flutter/issues/34539" target="_blank" rel="noopener">can tabBar not centered ?</a>  过了几天，flutter 工程师还加了个这样标签 <a href="https://github.com/flutter/flutter/labels/f%3A%20material%20design" target="_blank" rel="noopener">f: material design</a> <a href="https://github.com/flutter/flutter/labels/framework" target="_blank" rel="noopener">framework</a> ，相当于承认了这个问题？哈哈</p>
<h2 id="自问自答"><a href="#自问自答" class="headerlink" title="自问自答"></a>自问自答</h2><p><code>isScrollable</code> 这个属性默认是 false 的，把他设成 <code>isScrollable = true</code> 后，发现到有个细节改变了，由原来充满这一行的的表现，变成“收敛”了。</p>
<img src="/2019/06/24/Flutter-tabBar一定要居中吗？/image-20190624114534451.png" title="充满整行">
<img src="/2019/06/24/Flutter-tabBar一定要居中吗？/image-20190624114702642.png" title="收敛">
<p>既然每个 tab 都收敛了，那么现在只剩下一个问题了：如何把整个 tabBar 向左对齐？</p>
<p>我第一个想到的是，把 tabBar 用个 container 包裹着，设置下 alignment 不就行了？</p>
<pre><code>Container(
      alignment: Alignment.topLeft,
      child: TabBar(
        labelColor: Colors.black,
        isScrollable: true,
        labelStyle: TextStyle(fontSize: 15, fontWeight: FontWeight.bold),
        unselectedLabelColor: Colors.grey,
        unselectedLabelStyle: TextStyle(fontSize: 11),
        controller: _tabController,
        tabs: tabs.map((e) =&gt; Tab(text: e)).toList(),
      ),
    )
</code></pre><p>是的，指定<code>alignment: Alignment.topLeft</code>这样就可以实现这种效果了</p>
<img src="/2019/06/24/Flutter-tabBar一定要居中吗？/image-20190624115311338.png" title="最终实现">
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>如果需要放在 Scaffold.appBar 里面的话，则需要额外实现 <code>PreferredSizeWidget</code> 这个接口，<code>PreferredSize</code> 这个 widget 就实现了这个接口，我们用 <code>PreferredSize</code> 再包一层,即可。</p>
<p>这里注意一下，<code>preferredSize</code> 这个属性， 并不是用来约束他的 child, 而是当这个组件本身没有设置任何约束时，对自己大小的一种声明。也就是说，如果外部对其是有约束的话，这个属性是用不着的。</p>
<blockquote>
<p>/// The size this widget would prefer if it were otherwise unconstrained.<br>/// A widget with a preferred size.<br>///<br>/// This widget does not impose any constraints on its child, and it doesn’t<br>/// affect the child’s layout in any way. It just advertises a preferred size<br>/// which can be used by the parent.</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/20/helloWorld/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/20/helloWorld/" itemprop="url">
                  C++
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-20T15:59:55+08:00">
                2018-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-1"><a href="#C-1" class="headerlink" title="C ++^1"></a>C ++<a href="为什么我打不出C">^1</a></h1><p><em>尽量不要使用指针和数组，因为太过底层，很可能出现不可预测的问题。尽量使用vector等对其的封装的高级用法。</em></p>
<h2 id="引用-vs-指针"><a href="#引用-vs-指针" class="headerlink" title="引用 vs 指针"></a>引用 vs 指针</h2><p><em>引用</em> 相当于变量的<strong>别名</strong></p>
<pre><code>int ivar = 1;
int &amp;i = ivar;
int *pi = &amp;ivar;

cout &lt;&lt; &quot;i = &quot;&lt;&lt; i &lt;&lt; endl; // 相当于i 为 ivar的别名
cout &lt;&lt; &quot;pi = &quot;&lt;&lt; pi &lt;&lt; endl;
cout &lt;&lt; &quot;*pi = &quot;&lt;&lt; *pi &lt;&lt; endl;
cout &lt;&lt; &quot;&amp;i = &quot;&lt;&lt; &amp;i &lt;&lt; endl;
cout &lt;&lt; &quot;&amp;ivar = &quot;&lt;&lt; &amp;ivar &lt;&lt; endl;
</code></pre><hr>
<p>i = 1<br>pi = 0x7fff5fbff73c<br>*pi = 1<br>&amp;i = 0x7fff5fbff73c</p>
<h2 id="amp-ivar-0x7fff5fbff73c"><a href="#amp-ivar-0x7fff5fbff73c" class="headerlink" title=" &amp;ivar = 0x7fff5fbff73c"></a> &amp;ivar = 0x7fff5fbff73c</h2><p>表明指针就是存放对象<em>地址</em>的地方。</p>
<h2 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h2><pre><code>const int *p = &amp;ivar;
int a = 4;
p = &amp;a;
</code></pre><p>​<br>​        int <em> const conPtr = &ivar;<br>​    
        </em>conPtr  = 4;</p>
<p><em>右边的总和不能变</em></p>
<pre><code>const int * const bothConptr = &amp;ivar;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/12/独立子工程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/12/独立子工程/" itemprop="url">
                  iOS项目部分代码独立子工程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-12T16:04:11+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目在迭代到一定程度的时候，自然而然地，就有需求去将某部分功能的代码独立出来，这也是个必然经过的重构阶段。<br>网上关于这部分的资料其实已经很全了，在这里我就总结一下这方面重构的感悟吧。</p>
<h2 id="mov-files"><a href="#mov-files" class="headerlink" title="mov files"></a>mov files</h2><p>这次commit log最多字眼字眼就是mov files了。一移动文件，svn肯定就有增有减的标记。一开始挺怕删的文件比加进去的多的，所以每次都数一下两者文件数量是否一致。<br>在这个动作之前，肯定肯定会对要操作的文件进行showInFinder，打开了，发现这真是个有趣的地方。<br><em>不同习惯的开发者，创建新文件的风格是不同</em><br>习惯不好的，对xcode的文件结构即使已经分了group了，但show in finder进去一团糟。<br>在这里总结出第一条：<br><em>new file的时候，finder文件结构尽量和xcode目录结构一样，一个文件夹对应一个group</em></p>
<p><em>还有有个小技巧：</em><br>每次改变finder文件结构后，最好都clean一下项目，然后再build,不然有大概率报错找不到头文件。</p>
<h2 id="在子工程里面"><a href="#在子工程里面" class="headerlink" title="在子工程里面"></a>在子工程里面</h2><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>这里应该是最麻烦的地方了。原来在主工程用到mainBundle的地方，通通要改成对应的子bundle。</p>
<h4 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a>bundle</h4><p>创建子工程bundle具体操作如下图<br>上图<br><img src="/2017/06/12/独立子工程/2.jpg" title="new bundle 1"><br><img src="/2017/06/12/独立子工程/3.jpg" title="new bundle 2"><br><img src="/2017/06/12/独立子工程/4.jpg" title="add xib,img to bundle"><br><img src="/2017/06/12/独立子工程/5.jpg" title="add bundle to independece"></p>
<h2 id="在主项目里面"><a href="#在主项目里面" class="headerlink" title="在主项目里面"></a>在主项目里面</h2><h3 id="Build-Settings-user-header-Search-paths"><a href="#Build-Settings-user-header-Search-paths" class="headerlink" title="Build Settings -> user header Search paths"></a>Build Settings -> user header Search paths</h3><img src="/2017/06/12/独立子工程/1.jpg" title="header paths">
<h3 id="Build-Phases-link-binary-with-libaries"><a href="#Build-Phases-link-binary-with-libaries" class="headerlink" title="Build Phases -> link binary with libaries"></a>Build Phases -> link binary with libaries</h3><p>要在这里添加.a文件进去。</p>
<h3 id="Build-Phases-Copy-Bundle-Resources"><a href="#Build-Phases-Copy-Bundle-Resources" class="headerlink" title="Build Phases -> Copy Bundle Resources"></a>Build Phases -> Copy Bundle Resources</h3><p>把子工程的资源文件.bundle添加进去。<br><img src="/2017/06/12/独立子工程/1-1.jpg" title="link binary, copo Bundle"></p>
<h3 id="Build-Phases-Target-Dependencies"><a href="#Build-Phases-Target-Dependencies" class="headerlink" title="Build Phases -> Target Dependencies"></a>Build Phases -> Target Dependencies</h3><p>配置依赖，把在子工程添加进去。这样每次编译的时候，就会先把里面的子工程编译过了，再去搞主工程。没弄这个的话，每次一动子工程什么地方了，必须特定对那个子工程进行build···</p>
<h2 id="子工程加载图片-imageName"><a href="#子工程加载图片-imageName" class="headerlink" title="子工程加载图片 imageName:?"></a>子工程加载图片 imageName:?</h2><p>从上面步骤下来，子工程用代码加载子bundle图片是加载不出来的，特别是iOS7，连xib 都load不出图片来。7以上是可以的。<br>因为直接用imageName：是有问题的,load 出来是nil来的。<br>看api才知道，imageName:是load from main bundle的，对于子bundle，代码要做如下处理</p>
<pre><code>+ (NSString *)resourceName:(NSString *)name withBundleName:(NSString *)bundleName
{
    return [NSString stringWithFormat:@&quot;%@.bundle/%@&quot;, bundleName, name];
}

+ (UIImage *)imageNamed:(NSString *)imageName withBundleName:(NSString *)bundleName
{
    NSBundle *bundle = [self bundleNamed:bundleName];
    if (SystemLessThan(8.0)) {
        NSString *path = [[bundle resourcePath] stringByAppendingPathComponent:imageName];
        UIImage *image = [UIImage imageWithContentsOfFile:path];
        return image;
    }
    else {
        return [UIImage imageNamed:imageName inBundle:bundle compatibleWithTraitCollection:nil];
    }
}

+ (NSArray *)loadNibNamed:(NSString *)name owner:(id)owner withBundleName:(NSString *)bundleName
{
    NSBundle *bundle = [self bundleNamed:bundleName];
    return [bundle loadNibNamed:name owner:owner options:nil];
}

+ (NSBundle *)bundleNamed:(NSString *)bundleName
{
    NSString *bundlePath = [[NSBundle mainBundle] pathForResource:bundleName ofType:@&quot;bundle&quot;];
    return [NSBundle bundleWithPath:bundlePath];
}
</code></pre><p>这里需要特别注意，这个方法无法直接加载image assets里@2x图片，必须逐一把图片拉出来，然后加进bundle里面，才可以成功读取···</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/08/20173-6/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/08/20173-6/" itemprop="url">
                  圆角为何不圆？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-08T14:39:17+08:00">
                2017-06-08
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天遇到了个挺离奇的问题，丫的，设的圆角总是缺了个角。<br>上图<img src="/2017/06/08/20173-6/test.jpg" title="This is an example image"><br>眼看，因为一直感觉总是左边圆缺的那一块，就是右边圆多的那一块，所以一直查代码，觉得原因出在前后两个空间重叠了。<br>到了把两个圆拉到很远了，丫的，还是不圆，我就奔溃了··<br>耗了很久，才发现与画圆角算法无关，是像素点惹的祸！</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>像素对不齐！<br>一开始以为是高度是奇数出问题<br>因为是做全圆角的，所以角度是取1/height,当时height = 21,在retina屏，21*2 = 42,偶数。 其实关系不大。<br>影响效果最大是宽度的值<em>太精确了</em><br>之前之所以一直没遇到过这个问题，莫过于，正常情况下，我们都把宽高写死了，都是用那些很正常的整数吧，自己不会故意把值设成30.78这么奇葩吧···，</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>小数取整，在C语言有几种选择：</p>
<ul>
<li>ceil()</li>
<li>floor()</li>
<li>round()<br>当然选其中的round()来四舍五入了。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Terrence">
          <p class="site-author-name" itemprop="name">Terrence</p>
          <p class="site-description motion-element" itemprop="description">上帝只救自救者</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Terrence</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  




  
  

  

  

  

  


</body>
</html>
