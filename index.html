<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="上帝只救自救者">
<meta property="og:type" content="website">
<meta property="og:title" content="I&#39;m Terrence">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="I&#39;m Terrence">
<meta property="og:description" content="上帝只救自救者">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="I&#39;m Terrence">
<meta name="twitter:description" content="上帝只救自救者">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title> I'm Terrence </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">I'm Terrence</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/23/study swift/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/09/23/study swift/" itemprop="url">
                  Swift 学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-23T17:16:50+08:00">
                2020-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="self-跟-Type-傻傻分不清"><a href="#self-跟-Type-傻傻分不清" class="headerlink" title=".self 跟 .Type 傻傻分不清"></a>.self 跟 .Type 傻傻分不清</h2><p>Int.Type 是 Int 的元类型()，而 Int.Type 跟 Int.self 的关系，就是 Int 跟 5 的关系，一个是类型，一个是值</p>
<h2 id="什么是元类型？"><a href="#什么是元类型？" class="headerlink" title="什么是元类型？"></a>什么是元类型？</h2><p>我们通过元类型，去调用这个类的 static 方法,个人感觉，有点像 oc 被类对象的 isa 指针所指向的 meta Class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Int.max</span><br><span class="line"></span><br><span class="line">//实际上等价于：</span><br><span class="line"></span><br><span class="line">Int.self.max</span><br><span class="line"></span><br><span class="line">//只是编译器帮我们省去了这个self</span><br></pre></td></tr></table></figure>
<h2 id="protocol-Type"><a href="#protocol-Type" class="headerlink" title="protocol.Type?"></a>protocol.Type?</h2><p>首先 protocol 不是一个类型，只有他被一个类实现了，才具有元类型这个说法</p>
<h2 id="show-me-the-code"><a href="#show-me-the-code" class="headerlink" title="show me the code"></a>show me the code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">protocol MYStrategy &#123;</span><br><span class="line">    func cal() -&gt; Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class PlanA : MYStrategy &#123;</span><br><span class="line">    required init() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    func cal() -&gt; Int &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class  PlanB : MYStrategy &#123;</span><br><span class="line">    required init() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    func cal() -&gt; Int &#123;</span><br><span class="line">        return 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct PlanFactory &#123;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">        根据类型推断，免去传参的烦恼</span><br><span class="line">     */</span><br><span class="line">    static func createPlan&lt;T: MYStrategy&gt;() -&gt; T? &#123;</span><br><span class="line">        if let planA = T.self as? PlanA.Type &#123;</span><br><span class="line">            return planA.init() as? T</span><br><span class="line">        &#125;</span><br><span class="line">        if let planB = T.self as? PlanB.Type &#123;</span><br><span class="line">            return planB.init() as? T</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">        type 传入的是一个元类型的值，由于 MYStrategy 是 protocol，这里传一个实现了 MYStrategy 的类的元类型的值即可</span><br><span class="line">     */</span><br><span class="line">    static func createPlanV2(type: MYStrategy.Type) -&gt; MYStrategy? &#123;</span><br><span class="line">        if type == PlanA.self &#123;</span><br><span class="line">            return PlanA()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if type == PlanB.self &#123;</span><br><span class="line">            return PlanB()</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MainTest &#123;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        var plan:PlanA? = PlanFactory.createPlan()</span><br><span class="line">        </span><br><span class="line">        var planT = PlanFactory.createPlanV2(type: PlanA.self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="type-of：-跟-self"><a href="#type-of：-跟-self" class="headerlink" title="type(of：) 跟 .self"></a>type(of：) 跟 .self</h2><p>相同点：都是获取 metaType (元类型)</p>
<p>不同点：<code>type(of: value)</code>, 其中参数value 是个对象实例，主要用于动态获取 value 的 元类型；而 XXX.self 是静态获取 XXX 的元类型，其中 XXX 是个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var testString = &quot;123&quot;</span><br><span class="line">var a = type(of: testString) //String</span><br><span class="line">var b = String.self     //String</span><br><span class="line">var c = testString.self // 123</span><br></pre></td></tr></table></figure>
<h2 id="Self"><a href="#Self" class="headerlink" title="Self"></a>Self</h2><p>在协议中用得比较多用来表示遵循这个协议的对象<br>这里用例子自定义命名空间的例子来说明一下（仿照rxSwift）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  这个 struct 作为命名空间 Xr </span><br><span class="line">  Base 是泛型</span><br><span class="line">*/</span><br><span class="line">public struct Xr&lt;Base&gt; &#123;</span><br><span class="line">    public let base: Base</span><br><span class="line">    public init(_ base: Base) &#123;</span><br><span class="line">        self.base = base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    协议 + 关联类型</span><br><span class="line">    一个静态 getter, 一个实例 getter</span><br><span class="line"> */</span><br><span class="line">public protocol XrCompatible &#123;</span><br><span class="line">    associatedtype XrBase</span><br><span class="line">    static var xr: Xr&lt;XrBase&gt;.Type &#123; get &#125;</span><br><span class="line">    var xr: Xr&lt;XrBase&gt; &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    扩展 XrCompatible，写默认实现</span><br><span class="line">    限定 Base 类型为 Self</span><br><span class="line"> */</span><br><span class="line">extension XrCompatible &#123;</span><br><span class="line">    </span><br><span class="line">    //这里的几个 Self， 是给 Xr 的&lt;Base&gt; 泛型做了限制，限制为遵循这个协议的对象本身</span><br><span class="line">    </span><br><span class="line">    //静态 xr getter,用于扩展类方法</span><br><span class="line">    public static var xr: Xr&lt;Self&gt;.Type &#123;</span><br><span class="line">        get &#123; Xr&lt;Self&gt;.self &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //实例 xr getter，用于扩展实例方法</span><br><span class="line">    public var xr: Xr&lt;Self&gt; &#123;</span><br><span class="line">        get &#123; Xr(self) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    赋予以下类 XrCompatible 的能力，可以直接用默认实现的两个 getter 来玩，让他们有了 XX.xr 的命名空间</span><br><span class="line"> */</span><br><span class="line">extension NSObject: XrCompatible &#123; &#125;</span><br><span class="line">extension String: XrCompatible &#123; &#125;</span><br><span class="line">extension Data: XrCompatible &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    对 Xr 且 base 是 String 类型的进行扩展，新增方法 appendHaha</span><br><span class="line"> */</span><br><span class="line">extension Xr where Base == String &#123;</span><br><span class="line">    func appendHaha() -&gt; String &#123;</span><br><span class="line">        return base+&quot;haha&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let testString = &quot;123&quot;.xr.appendHaha()</span><br><span class="line">// 123haha</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/30/mobX flutter 数据流动/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/06/30/mobX flutter 数据流动/" itemprop="url">
                  MobX Flutter 数据流动原理篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-30T17:23:17+08:00">
                2020-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>MoTouch 项目中的状态管理大部分是基于 MobX 的， 使用方法就不在这里说了，详见 <a href="https://mobx.netlify.app/getting-started" target="_blank" rel="noopener">MobX官网</a>。</p>
<p> 使用过的同学们都知道，当 Observer builder 里面某个 MobX 属性发生改变时，就会自动刷新 Observer 了。但我一直有个疑问，为什么数据不用进行显式的绑定，到底是在哪里进行绑定的？如何才能确定某个属性已经被正确监听了？带着这些疑问，我们一起学习下源码。</p>
<h1 id="类结构分工"><a href="#类结构分工" class="headerlink" title="类结构分工"></a>类结构分工</h1><h2 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h2><p>被观察对象<br>Atom 对象是由 xxx.g.dart 生成, 实际上，我们每标记一个 @observable 属性，在 .g.dart 生成 getter 跟 setter 及对应的 atom, 通过 <code>_atom.reportRead()</code> 和 <code>_atom.reportWrite()</code> 来触发 ReactiveContext 的数据绑定及分发。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:mobx/mobx.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">part</span> <span class="string">'counter.g.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> = <span class="title">_Counter</span> <span class="title">with</span> <span class="title">_</span>$<span class="title">Counter</span>; //外面实例化的是这个 <span class="title">Counter</span>， 实际上 是把<span class="title">_</span>$<span class="title">Counter</span> 这个 <span class="title">Mixin</span> 实例化了</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">abstract</span> <span class="title">class</span> <span class="title">_Counter</span> <span class="title">with</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="meta">@observable</span></span><br><span class="line">  <span class="built_in">int</span> value = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@observable</span></span><br><span class="line">	ObservableMap&lt;<span class="built_in">String</span>, Size&gt; uidVideoSizeMap = ObservableMap();</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@action</span></span><br><span class="line">  <span class="keyword">void</span> increment() &#123;</span><br><span class="line">    value++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">part</span> of <span class="string">'counter.dart'</span>;</span><br><span class="line"></span><br><span class="line">mixin _$Counter on _Counter, Store &#123;<span class="comment">// _$Counter 又继承了_Counter</span></span><br><span class="line">  <span class="keyword">final</span> _$valueAtom = Atom(name: <span class="string">'_Counter.value'</span>);</span><br><span class="line">  ···</span><br><span class="line">  <span class="keyword">final</span> _$uidVideoSizeMapAtom = Atom(name: <span class="string">'_Counter.uidVideoSizeMap'</span>);</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><h3 id="0-3-8"><a href="#0-3-8" class="headerlink" title="0.3.8"></a>0.3.8</h3><p>项目最早是用 0.3.8 版本的，很有印象，Observer 其核心就是个 StatefulWidget 而已，一旦数据变化，内部通过调用 setState(), 触发 State 的刷新，从而触发 builder 的刷新。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> invalidate() =&gt; setState(noOp);</span><br></pre></td></tr></table></figure>
<h3 id="1-1-0"><a href="#1-1-0" class="headerlink" title="1.1.0"></a>1.1.0</h3><p>而到了 1.1.0 版本，Observer 的实现就有所不同了，不再是个StatefulWidget, 而是个 StatelessWidget了。主角是 elemtent , 核心通过 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void invalidate() =&gt; markNeedsBuild();</span><br></pre></td></tr></table></figure>
<p>标记 当前 element 为 dirty, 在下一帧触发相应的 build 方法。</p>
<h2 id="Reaction（ReactionImpl，Derivation）"><a href="#Reaction（ReactionImpl，Derivation）" class="headerlink" title="Reaction（ReactionImpl，Derivation）"></a>Reaction（ReactionImpl，Derivation）</h2><p>被 Observer 持有，封装数据绑定，更新回调方法。Reaction.run 回调给 Observer</p>
<h2 id="ReactiveContext"><a href="#ReactiveContext" class="headerlink" title="ReactiveContext"></a>ReactiveContext</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final ReactiveContext mainContext = createContext(config: ReactiveConfig.main);</span><br></pre></td></tr></table></figure>
<p>是个巨大的单例，负责处理 Atom 跟 Reaction 的依赖关系, 及进行数据方法绑定、分发、解绑等逻辑。</p>
<h1 id="数据流动过程"><a href="#数据流动过程" class="headerlink" title="数据流动过程"></a>数据流动过程</h1><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p> 整个数据绑定过程，在 0.3.8 版本是发生在 Observer State 的 build 里面，而在 1.1.0 版本，是在 Observer Element 的 build 方法体内。</p>
<h3 id="1-start-tracking"><a href="#1-start-tracking" class="headerlink" title="1. start tracking"></a>1. start tracking</h3><p>在 ReactiveContext 单例记录当前的 derivation。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Derivation _startTracking(Derivation derivation) &#123;</span><br><span class="line">    <span class="keyword">final</span> prevDerivation = _state.trackingDerivation;</span><br><span class="line">    _state.trackingDerivation = derivation;</span><br><span class="line"></span><br><span class="line">    _resetDerivationState(derivation);</span><br><span class="line">    derivation._newObservables = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prevDerivation;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-reportObserved"><a href="#2-reportObserved" class="headerlink" title="2. reportObserved()"></a>2. reportObserved()</h3><p><img src="http://emyms.bs2dl.yy.com/MzIyMDhlMzgtMThmMy00YzQ2LTg0NDUtMWVkYmJjOGZiNzUx.png" alt="image-20200623114315072"></p>
<p>看堆栈可以知道，对于每一次 @Observable 对象的 get 调用，实际上是  <code>atom.reportObserved()</code> ，最终调用ReaciveContext 的 <code>_reportObserved</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _reportObserved(Atom atom) &#123;</span><br><span class="line">    <span class="keyword">final</span> derivation = _state.trackingDerivation; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (derivation != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 把 atom 加到当前的 derivation 的新观察队列里面</span></span><br><span class="line">      derivation._newObservables.add(atom);</span><br><span class="line">      <span class="keyword">if</span> (!atom._isBeingObserved) &#123;</span><br><span class="line">        atom</span><br><span class="line">          .._isBeingObserved = <span class="keyword">true</span></span><br><span class="line">          .._notifyOnBecomeObserved();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-endTracking"><a href="#3-endTracking" class="headerlink" title="3. endTracking"></a>3. endTracking</h3><p><img src="http://emyms.bs2dl.yy.com/ZDc5OGRkYjAtYWJlZC00OTZjLWJhZGQtNzlmYTZhNTdlYzQ1.png" alt="image-20200622143205460"></p>
<p>把在 startTracking 跟 endTracking  之间， 所有被调用  <code>reportRead()</code> 的 atom， 绑定当前观察者 derivation 。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _bindDependencies(Derivation derivation) &#123;</span><br><span class="line">  <span class="comment">// 这里对 Set 搞了两次difference， 目的是把新、旧 atoms 分开。旧的清空数据，新的绑定观察者</span></span><br><span class="line">  <span class="keyword">final</span> staleObservables =</span><br><span class="line">      derivation._observables.difference(derivation._newObservables);</span><br><span class="line">  <span class="keyword">final</span> newObservables =</span><br><span class="line">      derivation._newObservables.difference(derivation._observables);</span><br><span class="line">  <span class="keyword">var</span> lowestNewDerivationState = DerivationState.upToDate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add newly found observables</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> observable <span class="keyword">in</span> newObservables) &#123;</span><br><span class="line">    observable._addObserver(derivation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Computed = Observable + Derivation</span></span><br><span class="line">    <span class="keyword">if</span> (observable <span class="keyword">is</span> Computed) &#123;</span><br><span class="line">      <span class="keyword">if</span> (observable._dependenciesState.index &gt;</span><br><span class="line">          lowestNewDerivationState.index) &#123;</span><br><span class="line">        lowestNewDerivationState = observable._dependenciesState;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove previous observables</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> ob <span class="keyword">in</span> staleObservables) &#123;</span><br><span class="line">    ob._removeObserver(derivation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lowestNewDerivationState != DerivationState.upToDate) &#123;</span><br><span class="line">    derivation</span><br><span class="line">      .._dependenciesState = lowestNewDerivationState</span><br><span class="line">      .._onBecomeStale();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  derivation</span><br><span class="line">    .._observables = derivation._newObservables</span><br><span class="line">    .._newObservables = &#123;&#125;; <span class="comment">// No need for newObservables beyond this point</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="reportWrite"><a href="#reportWrite" class="headerlink" title="reportWrite()"></a>reportWrite()</h3><p>当数据更新 atom.reportWrite() 主要做了这两件事：</p>
<ol>
<li>更新 数据</li>
<li>把 与之绑定 derivation (即 reaction) 加到队列。</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> reportWrite&lt;T&gt;(T newValue, T oldValue, <span class="keyword">void</span> <span class="built_in">Function</span>() setNewValue) &#123;</span><br><span class="line">  context.spyReport(ObservableValueSpyEvent(<span class="keyword">this</span>,</span><br><span class="line">      newValue: newValue, oldValue: oldValue, name: name));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ignore: cascade_invocations</span></span><br><span class="line">  context.conditionallyRunInAction(() &#123;</span><br><span class="line">    setNewValue();</span><br><span class="line">    reportChanged();<span class="comment">//触发 Context.addPendingReaction(reaction)</span></span><br><span class="line">  &#125;, <span class="keyword">this</span>, name: <span class="string">'<span class="subst">$&#123;name&#125;</span>_set'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ignore: cascade_invocations</span></span><br><span class="line">  context.spyReport(EndedSpyEvent(type: <span class="string">'observable'</span>, name: name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把 reaction 添加到队列, 这里 reaction 就是 ReactionImpl</span></span><br><span class="line"><span class="keyword">void</span> addPendingReaction(Reaction reaction) &#123;</span><br><span class="line">  _state.pendingReactions.add(reaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据分发"><a href="#数据分发" class="headerlink" title="数据分发"></a>数据分发</h2><h3 id="action"><a href="#action" class="headerlink" title="@action"></a>@action</h3><p><img src="http://emyms.bs2dl.yy.com/YTc1ZmY4MzAtMjk3Yy00MzA2LTkyZDctMjY2NDhmMmUzMDg2.png" alt="image-20200622151359216"></p>
<h3 id="不带-action"><a href="#不带-action" class="headerlink" title="不带 @action"></a>不带 @action</h3><p><img src="http://emyms.bs2dl.yy.com/NjM4ZWQ0MjgtOTc1My00ZGE5LTgyZDYtMDUwZjFlODI3ZjNh.png" alt="image-20200622152046571"></p>
<p>带不带 @action 的区别，其实就是 下面这个地方有没把 <code>ActionController</code> 传入来，数据流向其实是一样的，都会由 <code>controller.endAction(runInfo);</code> 来触发。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> conditionallyRunInAction(<span class="keyword">void</span> <span class="built_in">Function</span>() fn, Atom atom,</span><br><span class="line">    &#123;<span class="built_in">String</span> name, ActionController actionController&#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isWithinBatch) &#123;</span><br><span class="line">    enforceWritePolicy(atom);</span><br><span class="line">    fn();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> controller = actionController ??</span><br><span class="line">        ActionController(</span><br><span class="line">            context: <span class="keyword">this</span>, name: name ?? nameFor(<span class="string">'conditionallyRunInAction'</span>));</span><br><span class="line">    <span class="keyword">final</span> runInfo = controller.startAction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      enforceWritePolicy(atom);</span><br><span class="line">      fn();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      controller.endAction(runInfo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _runReactionsInternal() &#123;</span><br><span class="line">  _state.isRunningReactions = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从队列读取 reaction</span></span><br><span class="line">  <span class="keyword">var</span> iterations = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> allReactions = _state.pendingReactions;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (allReactions.isNotEmpty) &#123;</span><br><span class="line">    <span class="comment">// 这里是抛出死循环的情况</span></span><br><span class="line">    <span class="keyword">if</span> (++iterations == config.maxIterations) &#123;</span><br><span class="line">      <span class="keyword">final</span> failingReaction = allReactions[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Resetting ensures we have no bad-state left</span></span><br><span class="line">      _resetState();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">throw</span> MobXCyclicReactionException(</span><br><span class="line">          <span class="string">"Reaction doesn't converge to a stable state after <span class="subst">$&#123;config.maxIterations&#125;</span> iterations. Probably there is a cycle in the reactive function: $failingReaction"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> remainingReactions = allReactions.toList(growable: <span class="keyword">false</span>);</span><br><span class="line">    allReactions.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> reaction <span class="keyword">in</span> remainingReactions) &#123;</span><br><span class="line">      reaction._run();<span class="comment">//分发，回调给 Observer 层</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _state</span><br><span class="line">    ..pendingReactions = []</span><br><span class="line">    ..isRunningReactions = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最终触发-rebuild"><a href="#最终触发-rebuild" class="headerlink" title="最终触发 rebuild"></a>最终触发 rebuild</h3><h4 id="0-3-8-1"><a href="#0-3-8-1" class="headerlink" title="0.3.8"></a>0.3.8</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//observer.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Observer</span>&gt; </span>&#123;</span><br><span class="line">		<span class="keyword">void</span> invalidate() =&gt; setState(noOp);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-0-1"><a href="#1-1-0-1" class="headerlink" title="1.1.0"></a>1.1.0</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//observer_widget_mixin.dart</span></span><br><span class="line">	mixin ObserverElementMixin on ComponentElement &#123;</span><br><span class="line">	<span class="comment">//reaction.run 回调给 Observer 层，通过 markNeedsBuild 触发 rebuild</span></span><br><span class="line">	<span class="keyword">void</span> invalidate() =&gt; markNeedsBuild();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h2><p>因为 MobX 里面存在一个 ReactiveContext 单例，那就涉及到对数据的清除绑定了</p>
<p><img src="http://emyms.bs2dl.yy.com/MWFkZmY0YWMtNzM1OS00ZTVlLTk1YzUtMzA4NDBhMjU2ZWQz.png" alt="image-20200622164901647"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void _clearObservables(Derivation derivation) &#123;</span><br><span class="line">    final observables = derivation._observables;</span><br><span class="line">    derivation._observables = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    for (final x in observables) &#123;</span><br><span class="line">    //打破 atom 跟 reaction 的双向依赖</span><br><span class="line">      x._removeObserver(derivation);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    derivation._dependenciesState = DerivationState.notTracking;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>在实际开发过程中，我们项目会遇到一些数据更新了，但没触发 Observer rebuild 的一些疑问，在弄清楚数据流向后，现在可以基本解决了。</p>
<p><code>Counter</code> 还是用上文那个例子,我们这次是对其中MobX 提供的 <code>ObservableMap</code> 进行监听，意图监听 map 的增减操作。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_mobx/flutter_mobx.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:mobx/mobx.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:motouch/UI/Me/counter.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterExample</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> CounterExample();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  CounterExampleState createState() =&gt; CounterExampleState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterExampleState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CounterExample</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Counter counter = Counter();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          backgroundColor: Colors.blue,</span><br><span class="line">          title: <span class="keyword">const</span> Text(<span class="string">'MobX Counter'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Column(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Observer(</span><br><span class="line">                builder: (_) &#123;</span><br><span class="line">                  <span class="comment">//bind 1</span></span><br><span class="line">                  counter.uidVideoSizeMap;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//bind 2</span></span><br><span class="line"><span class="comment">//                  counter.uidVideoSizeMap.length;</span></span><br><span class="line">                  </span><br><span class="line">                  <span class="built_in">print</span>(<span class="string">'rebuild'</span>);</span><br><span class="line">                  <span class="keyword">return</span> Container();</span><br><span class="line">                &#125;,</span><br><span class="line">              ),</span><br><span class="line">              MaterialButton(</span><br><span class="line">                child: Text(<span class="string">'对 counter.uidVideoSizeMap 重新赋值'</span>),</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  <span class="comment">//update 1</span></span><br><span class="line">                  <span class="built_in">print</span>(<span class="string">'对 counter.uidVideoSizeMap 重新赋值'</span>);</span><br><span class="line">                  counter.uidVideoSizeMap = ObservableMap();</span><br><span class="line">                &#125;,</span><br><span class="line">              ),</span><br><span class="line">              MaterialButton(</span><br><span class="line">                child: Text(<span class="string">'counter.uidVideoSizeMap 增减元素'</span>),</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  <span class="comment">//update 2</span></span><br><span class="line">                  <span class="built_in">print</span>(<span class="string">'counter.uidVideoSizeMap 增减元素'</span>);</span><br><span class="line">                  counter.uidVideoSizeMap[<span class="string">'1'</span>] = Size.zero;</span><br><span class="line">                &#125;,</span><br><span class="line">              ),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分绑定分2种方式，我们先注释 bind 2，用 <code>counter.uidVideoSizeMap</code>绑定，看看打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (20534): 对 counter.uidVideoSizeMap 重新赋值</span><br><span class="line">I/flutter (20534): rebuild</span><br><span class="line">I/flutter (20534): 对 counter.uidVideoSizeMap 重新赋值</span><br><span class="line">I/flutter (20534): rebuild</span><br><span class="line">I/flutter (20534): 对 counter.uidVideoSizeMap 重新赋值</span><br><span class="line">I/flutter (20534): rebuild</span><br><span class="line">I/flutter (20534): counter.uidVideoSizeMap 增减元素</span><br><span class="line">I/flutter (20534): counter.uidVideoSizeMap 增减元素</span><br></pre></td></tr></table></figure>
<p>可见，bind 1 这种方式，增减元素是不会引起 Observer 的 rebuild 的。</p>
<p>再来看看注释 bind 1, 打开 <code>counter.uidVideoSizeMap.length</code>的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (20534): 对 counter.uidVideoSizeMap 重新赋值</span><br><span class="line">I/flutter (20534): rebuild</span><br><span class="line">I/flutter (20534): 对 counter.uidVideoSizeMap 重新赋值</span><br><span class="line">I/flutter (20534): rebuild</span><br><span class="line">I/flutter (20534): counter.uidVideoSizeMap 增减元素</span><br><span class="line">I/flutter (20534): rebuild</span><br><span class="line">I/flutter (20534): counter.uidVideoSizeMap 增减元素</span><br></pre></td></tr></table></figure>
<p>bind 2 的方式，无论是重新赋值，还是增减元素，都能引起 Observer 的 rebuild 。</p>
<p>结合源码来分析，bind 1这种绑定方式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//counter.g.dart</span></span><br><span class="line"><span class="comment">// 在 Observer builder 方法体内，每次 counter.uidVideoSizeMap, 触发的是 _Counter.uidVideoSizeMap 这个属性 atom 的 reportRead()， 绑定的是这个属性本身，跟 ObserverMap 的类型无关。</span></span><br><span class="line">  <span class="keyword">final</span> _$uidVideoSizeMapAtom = Atom(name: <span class="string">'_Counter.uidVideoSizeMap'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ObservableMap&lt;<span class="built_in">String</span>, Size&gt; <span class="keyword">get</span> uidVideoSizeMap &#123;</span><br><span class="line">    _$uidVideoSizeMapAtom.reportRead();<span class="comment">//内里调用 reportObserver()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.uidVideoSizeMap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>bind 2:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//observable_map.dart </span></span><br><span class="line"><span class="comment">// 在 Observer builder 方法体内，调用 counter.uidVideoSizeMap.length，是把 Observer_map 里面实现 的 _atom 给绑定了。</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> length &#123;</span><br><span class="line">    _context.enforceReadPolicy(_atom);</span><br><span class="line"></span><br><span class="line">    _atom.reportObserved();<span class="comment">//绑定</span></span><br><span class="line">    <span class="keyword">return</span> _map.length;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可见， bind 1, bind 2两种绑定方式，决定了 reaction 的不同， bind 1 那种方式完全把 uidVideoSizeMap 当成普通类型来用了，压根没有把 <code>ObservableMap</code> 类型带给我们便利给用上。</p>
<p><code>ObservableList</code>, <code>ObservableSet</code> 也同理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/thunder 黑屏/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/03/03/thunder 黑屏/" itemprop="url">
                  Flutter 实战系列： 记一次视频区域黑屏问题分析与解决
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-03T21:34:02+08:00">
                2020-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>咱们 MoTouch 项目中的直播间内的视频区域是通过 flutter platform view  + Thunder SDK 实现的，而在开发和测试过程中，iOS 侧频频出现莫名其妙的黑屏问题，而且是整个远端视图都黑了，分析日志后，发现： thunder 的远端流通知跟远端视图的首帧回调到来了，但视频区域还是黑的，怀疑是由于业务层调用接口不恰当引起的，这里记录一下问题的分析和解决。</p>
<h2 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h2><h3 id="哪里黑屏了"><a href="#哪里黑屏了" class="headerlink" title="哪里黑屏了"></a>哪里黑屏了</h3><p>既然 thunder 那边首帧回调都过来了，大概率是业务层这边的不恰当处理了···第一反应是这个这个 platform view 到底有没加上视图？ frame 到底对不对？<br>等在 debug 复现黑屏情况后，在 xcode 看过视图层级，发现这个时候的 frame，size 都没问题，后来还是在 SDK 的同学帮忙排查下，才发现，是在调用 FlutterThunder.setRemoteVideoLayout 的时候，view 的 frame 是 0，导致 sdk 这个 video 的 frame 是 0 了，即使后来  view 的 frame 对了，但是没更新到 FlutterThunder 那边。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Widget _remoteMixinWidget() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_remoteViewWidget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    _remoteViewWidget = FlutterThunder.createNativeView((viewId) &#123;</span><br><span class="line">      remoteViewId = viewId;</span><br><span class="line">      FlutterThunder.setRemoteVideoLayout(...)<span class="comment">// 这句调用时机不对， platform view 的 frame 还是 0</span></span><br><span class="line">    &#125;, key: _remoteKey);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _remoteViewWidget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="frame-为啥是-0-？"><a href="#frame-为啥是-0-？" class="headerlink" title="frame 为啥是 0 ？"></a>frame 为啥是 0 ？</h3><p>翻翻 engine 的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//FlutterPlatformViews.mm</span><br><span class="line"></span><br><span class="line">void FlutterPlatformViewsController::OnCreate(FlutterMethodCall* call, FlutterResult&amp; result) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  NSObject&lt;FlutterPlatformView&gt;* embedded_view = [factory createWithFrame:CGRectZero</span><br><span class="line">                                                           viewIdentifier:viewId</span><br><span class="line">                                                                arguments:params];// 这个 CGRectZero 是engine 自己塞的</span><br><span class="line">  views_[viewId] = fml::scoped_nsobject&lt;NSObject&lt;FlutterPlatformView&gt;&gt;([embedded_view retain]);</span><br><span class="line"></span><br><span class="line">  FlutterTouchInterceptingView* touch_interceptor = [[[FlutterTouchInterceptingView alloc]</span><br><span class="line">                  initWithEmbeddedView:embedded_view.view</span><br><span class="line">                 flutterViewController:flutter_view_controller_.get()</span><br><span class="line">      gestureRecognizersBlockingPolicy:gesture_recognizers_blocking_policies[viewType]]</span><br><span class="line">      autorelease];// 塞进 FlutterTouchInterceptingView</span><br><span class="line"></span><br><span class="line">  touch_interceptors_[viewId] =</span><br><span class="line">      fml::scoped_nsobject&lt;FlutterTouchInterceptingView&gt;([touch_interceptor retain]);</span><br><span class="line">  root_views_[viewId] = fml::scoped_nsobject&lt;UIView&gt;([touch_interceptor retain]);</span><br><span class="line"></span><br><span class="line">  result(nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见 platform view 初始化出来时，肯定是 CGRectZero 的。</p>
<p>但什么时候才是正确的呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithEmbeddedView:(UIView*)embeddedView</span><br><span class="line">               flutterViewController:(UIViewController*)flutterViewController</span><br><span class="line">    gestureRecognizersBlockingPolicy:</span><br><span class="line">        (FlutterPlatformViewGestureRecognizersBlockingPolicy)blockingPolicy &#123;</span><br><span class="line">  self = [super initWithFrame:embeddedView.frame];</span><br><span class="line">  if (self) &#123;</span><br><span class="line">    self.multipleTouchEnabled = YES;</span><br><span class="line">    embeddedView.autoresizingMask =</span><br><span class="line">        (UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight);</span><br><span class="line"></span><br><span class="line">    [self addSubview:embeddedView];</span><br><span class="line"></span><br><span class="line">    ForwardingGestureRecognizer* forwardingRecognizer =</span><br><span class="line">        [[[ForwardingGestureRecognizer alloc] initWithTarget:self</span><br><span class="line">                                       flutterViewController:flutterViewController] autorelease];</span><br><span class="line"></span><br><span class="line">    _delayingRecognizer.reset([[DelayingGestureRecognizer alloc]</span><br><span class="line">              initWithTarget:self</span><br><span class="line">                      action:nil</span><br><span class="line">        forwardingRecognizer:forwardingRecognizer]);</span><br><span class="line">    _blockingPolicy = blockingPolicy;</span><br><span class="line"></span><br><span class="line">    [self addGestureRecognizer:_delayingRecognizer.get()];</span><br><span class="line">    [self addGestureRecognizer:forwardingRecognizer];</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们都看得出来， FlutterPlatformView 实际上是被一个 FlutterTouchInterceptingView 包住的，其 frame 是跟随 FlutterTouchInterceptingView 大小</p>
<p>所以，我们顺藤摸瓜，看看 FlutterTouchInterceptingView 的 frame 到底在哪里改正确的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FlutterPlatformViewsController::CompositeWithParams(<span class="keyword">int</span> view_id,</span><br><span class="line">                                                         <span class="keyword">const</span> EmbeddedViewParams&amp; params) &#123;</span><br><span class="line">  <span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, params.sizePoints.width(), params.sizePoints.height());</span><br><span class="line">  <span class="built_in">UIView</span>* touchInterceptor = touch_interceptors_[view_id].get();</span><br><span class="line">  touchInterceptor.layer.transform = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">  touchInterceptor.frame = frame; <span class="comment">// 就是这里了</span></span><br><span class="line">  touchInterceptor.alpha = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="addPostFrameCallback"><a href="#addPostFrameCallback" class="headerlink" title="addPostFrameCallback?"></a>addPostFrameCallback?</h3><p>讲真，我们在 flutter 层其实对 native 的 frame 操作基本上是没有了，来看下我们都是怎么设置 platformView 的大小跟坐标的</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Widget remoteView() &#123;</span><br><span class="line">    <span class="keyword">return</span> Positioned(</span><br><span class="line">      top: <span class="number">0</span>,</span><br><span class="line">      left: <span class="number">0</span>,</span><br><span class="line">      child: Container(</span><br><span class="line">        color: Colors.black,</span><br><span class="line">        width: <span class="number">100</span>,</span><br><span class="line">        height: <span class="number">100</span>,</span><br><span class="line">        child: remoteMixinView,<span class="comment">//platformview</span></span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容易看出来，通过对 platform view 的 父亲节点（Container 之类）设置坐标宽高，让其跟随父亲节点的大小。</p>
<p>那这个 platform view 的 宽高跟坐标在 flutter 层什么时候才确定呢？</p>
<p>google 一下，  建议是在这个每帧回调里面打印：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WidgetsBinding.instance.addPostFrameCallback((_) &#123;</span><br><span class="line">          RenderBox renderBox = _key.currentContext.findRenderObject();</span><br><span class="line">          <span class="built_in">print</span>(</span><br><span class="line">              <span class="string">'<span class="subst">$&#123;renderBox.size&#125;</span>, <span class="subst">$&#123;renderBox.localToGlobal(Offset.zero)&#125;</span>'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个 WidgetsBinding 相当于连接 engine 跟 widget layer 的桥梁，而 postFrameCallBack 是在每一帧渲染后，回调执行的。</p>
<p>那这个 addPostFrameCallback 回调是否靠谱，我们得通过源码分析看看。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="要点复习"><a href="#要点复习" class="headerlink" title="要点复习"></a>要点复习</h3><p>既然涉及 .mm 跟 dart 的交互，我们先来看看 c++ 跟 dart 层是如何交互的：</p>
<h4 id="C-（Engine）-与-dart-Framework-交互"><a href="#C-（Engine）-与-dart-Framework-交互" class="headerlink" title="C ++（Engine） 与 dart (Framework) 交互"></a>C ++（Engine） 与 dart (Framework) 交互</h4><p>主要集中在这几个文件里面：window.dart, window.cc，hooks.dart</p>
<h5 id="dart-调用-c"><a href="#dart-调用-c" class="headerlink" title="dart 调用 c++"></a>dart 调用 c++</h5><p>window.cc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//注册 native 方法</span><br><span class="line">void Window::RegisterNatives(tonic::DartLibraryNatives* natives) &#123;</span><br><span class="line">  natives-&gt;Register(&#123;</span><br><span class="line">      &#123;&quot;Window_defaultRouteName&quot;, DefaultRouteName, 1, true&#125;,</span><br><span class="line">      &#123;&quot;Window_scheduleFrame&quot;, ScheduleFrame, 1, true&#125;,</span><br><span class="line">      &#123;&quot;Window_sendPlatformMessage&quot;, _SendPlatformMessage, 4, true&#125;,</span><br><span class="line">      &#123;&quot;Window_respondToPlatformMessage&quot;, _RespondToPlatformMessage, 3, true&#125;,</span><br><span class="line">      &#123;&quot;Window_render&quot;, Render, 2, true&#125;,</span><br><span class="line">      &#123;&quot;Window_updateSemantics&quot;, UpdateSemantics, 2, true&#125;,</span><br><span class="line">      &#123;&quot;Window_setIsolateDebugName&quot;, SetIsolateDebugName, 2, true&#125;,</span><br><span class="line">      &#123;&quot;Window_reportUnhandledException&quot;, ReportUnhandledException, 2, true&#125;,</span><br><span class="line">      &#123;&quot;Window_setNeedsReportTimings&quot;, SetNeedsReportTimings, 2, true&#125;,</span><br><span class="line">      &#123;&quot;Window_getPersistentIsolateData&quot;, GetPersistentIsolateData, 1, true&#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">void Render(Dart_NativeArguments args) &#123;</span><br><span class="line">  Dart_Handle exception = nullptr;</span><br><span class="line">  Scene* scene =</span><br><span class="line">      tonic::DartConverter&lt;Scene*&gt;::FromArguments(args, 1, exception);</span><br><span class="line">  if (exception) &#123;</span><br><span class="line">    Dart_ThrowException(exception);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  UIDartState::Current()-&gt;window()-&gt;client()-&gt;Render(scene);//这个 clinet() 实际是 engine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>window.dart<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void render(Scene scene) native &apos;Window_render&apos;;//实际上是调用 window.cc 的native 方法</span><br></pre></td></tr></table></figure></p>
<h5 id="c-调用-dart"><a href="#c-调用-dart" class="headerlink" title="c++ 调用 dart"></a>c++ 调用 dart</h5><p>hooks.dart</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pragma</span>(<span class="string">'vm:entry-point'</span>)</span><br><span class="line"><span class="comment">// ignore: unused_element</span></span><br><span class="line"><span class="keyword">void</span> _drawFrame() &#123;</span><br><span class="line">  _invoke(<span class="built_in">window</span>.onDrawFrame, <span class="built_in">window</span>._onDrawFrameZone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>window.dart</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VoidCallback get onDrawFrame =&gt; _onDrawFrame;</span><br></pre></td></tr></table></figure>
<p><img src="http://emyms.bs2dl.yy.com/YjM4M2E4ZDEtZTI0Yy00NjFkLTliNWYtYmVlZDZmYTczZTRl.jpg" alt="image-20200321233237397"></p>
<h3 id="相关交互流程"><a href="#相关交互流程" class="headerlink" title="相关交互流程"></a>相关交互流程</h3><p>整个渲染流程有点长，这里简要用白话总结下跟本文相关的几个交互步骤：</p>
<ol>
<li><p>Engine 层监听 Vsync 信号，通过 _drawFrame 告诉 framework 层，快准备好数据给我（Flutter::layer tree）</p>
</li>
<li><p>Framework 层在 window.onBeginFrame ， window.onDrawFrame 接收 Engine 的信息，把 widgets 的 UI 配置信息转化为 Layer, 最终产物是个 LayerTree ,通过 render() 发送个回 Engine</p>
</li>
<li><p>Engine 在 GPU 线程 处理 LayerTree,  主要通过 rasterizer 做栅格化操作（ 将 LayerTree 转化为 SkCanvas） </p>
</li>
<li><p>略····</p>
<p>更详细的交互流程可以看这位大神的 blog: <a href="http://gityuan.com/2019/06/15/flutter_ui_draw/" target="_blank" rel="noopener">http://gityuan.com/2019/06/15/flutter_ui_draw/</a></p>
</li>
</ol>
<p>   我们写界面实际上是不用接触到 Layer 的， 是 Framework 层做了转换，看下图，Container 对应的 flutter::ContainerLayer，PlatformView 对应 flutter::PlatformViewLayer， 他们都继承于 Flutter::layer。</p>
<p>   <img src="http://emyms.bs2dl.yy.com/MjYyMzBmMDktOGUwZS00YTBjLWFiNDMtYzNjMzhjMjkxODI5.jpg" alt="image-20200322154209908"></p>
<p>   <a href="https://engine.chinmaygarde.com/classflutter_1_1_layer.html" target="_blank" rel="noopener">https://engine.chinmaygarde.com/classflutter_1_1_layer.html</a></p>
<p>源码看到 PlatformViewLayer 这一层，其实离答案已经不远了。</p>
<h3 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h3><p>我们一起来看看 postFrameCallback 在被调用前究竟发生了什么？</p>
<p><img src="http://emyms.bs2dl.yy.com/ZWJkZTBmOTEtNWJiOC00MDY5LWFlMGUtOWZjZWJiM2ZmYjVi.jpg" alt="image-20200322154209908"></p>
<p>是先遍历执行了 _persistentCallbacks， 其中主角是下面的 drawFrame()，然后再遍历执行 postFrameCallback</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">///rendering/binding.dart</span><br><span class="line"></span><br><span class="line">  @protected</span><br><span class="line">  void drawFrame() &#123;</span><br><span class="line">    assert(renderView != null);</span><br><span class="line">    pipelineOwner.flushLayout();</span><br><span class="line">    pipelineOwner.flushCompositingBits();</span><br><span class="line">    pipelineOwner.flushPaint();</span><br><span class="line">    renderView.compositeFrame(); // this sends the bits to the GPU</span><br><span class="line">    pipelineOwner.flushSemantics(); // this also sends the semantics to the OS.</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中由  <code>renderView.compositeFrame();</code>触发， 通过 _window.render 把相关信息 由dart 层  widget ui 数据回传给 engine C++ 层：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void compositeFrame() &#123;</span><br><span class="line">   ...</span><br><span class="line">    _window.render(scene); //这里调用 window.dart 的 render(Scene scene)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Animator.cc</span><br><span class="line">void Animator::Render(std::unique_ptr&lt;flutter::LayerTree&gt; layer_tree) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//这个代理实际上是  shell.cc</span><br><span class="line">  delegate_.OnAnimatorDraw(layer_tree_pipeline_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里开始，已经转到 GPU 线程了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">///shell.cc</span><br><span class="line">// |Animator::Delegate|</span><br><span class="line">void Shell::OnAnimatorDraw(fml::RefPtr&lt;Pipeline&lt;flutter::LayerTree&gt;&gt; pipeline) &#123;</span><br><span class="line">  FML_DCHECK(is_setup_);</span><br><span class="line"></span><br><span class="line">  task_runners_.GetGPUTaskRunner()-&gt;PostTask(//切换线程</span><br><span class="line">      [&amp; waiting_for_first_frame = waiting_for_first_frame_,</span><br><span class="line">       &amp;waiting_for_first_frame_condition = waiting_for_first_frame_condition_,</span><br><span class="line">       rasterizer = rasterizer_-&gt;GetWeakPtr(),</span><br><span class="line">       pipeline = std::move(pipeline)]() &#123;</span><br><span class="line">        if (rasterizer) &#123;</span><br><span class="line">          rasterizer-&gt;Draw(pipeline);</span><br><span class="line"></span><br><span class="line">          if (waiting_for_first_frame.load()) &#123;</span><br><span class="line">            waiting_for_first_frame.store(false);</span><br><span class="line">            waiting_for_first_frame_condition.notify_all();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">///Rasterizer.cc</span><br><span class="line">void Rasterizer::Draw(fml::RefPtr&lt;Pipeline&lt;flutter::LayerTree&gt;&gt; pipeline) &#123;</span><br><span class="line">  TRACE_EVENT0(&quot;flutter&quot;, &quot;GPURasterizer::Draw&quot;);</span><br><span class="line">  if (gpu_thread_merger_ &amp;&amp; !gpu_thread_merger_-&gt;IsOnRasterizingThread()) &#123;</span><br><span class="line">    // we yield and let this frame be serviced on the right thread.</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  FML_DCHECK(task_runners_.GetGPUTaskRunner()-&gt;RunsTasksOnCurrentThread());</span><br><span class="line"></span><br><span class="line">  RasterStatus raster_status = RasterStatus::kFailed;</span><br><span class="line">  Pipeline&lt;flutter::LayerTree&gt;::Consumer consumer =</span><br><span class="line">      [&amp;](std::unique_ptr&lt;LayerTree&gt; layer_tree) &#123;</span><br><span class="line">        raster_status = DoDraw(std::move(layer_tree));</span><br><span class="line">      &#125;;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">RasterStatus Rasterizer::DoDraw(</span><br><span class="line">    std::unique_ptr&lt;flutter::LayerTree&gt; layer_tree) &#123;</span><br><span class="line">  FML_DCHECK(task_runners_.GetGPUTaskRunner()-&gt;RunsTasksOnCurrentThread());</span><br><span class="line"></span><br><span class="line">  if (!layer_tree || !surface_) &#123;</span><br><span class="line">    return RasterStatus::kFailed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FrameTiming timing;</span><br><span class="line">  timing.Set(FrameTiming::kBuildStart, layer_tree-&gt;build_start());</span><br><span class="line">  timing.Set(FrameTiming::kBuildFinish, layer_tree-&gt;build_finish());</span><br><span class="line">  timing.Set(FrameTiming::kRasterStart, fml::TimePoint::Now());</span><br><span class="line"></span><br><span class="line">  PersistentCache* persistent_cache = PersistentCache::GetCacheForProcess();</span><br><span class="line">  persistent_cache-&gt;ResetStoredNewShaders();</span><br><span class="line"></span><br><span class="line">  RasterStatus raster_status = DrawToSurface(*layer_tree);</span><br><span class="line">  if (raster_status == RasterStatus::kSuccess) &#123;</span><br><span class="line">    last_layer_tree_ = std::move(layer_tree);</span><br><span class="line">  &#125; else if (raster_status == RasterStatus::kResubmit) &#123;</span><br><span class="line">    resubmitted_layer_tree_ = std::move(layer_tree);</span><br><span class="line">    return raster_status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  return raster_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RasterStatus Rasterizer::DrawToSurface(flutter::LayerTree&amp; layer_tree) &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (compositor_frame) &#123;</span><br><span class="line">    RasterStatus raster_status = compositor_frame-&gt;Raster(layer_tree, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///compositor_context.cc</span></span><br><span class="line">RasterStatus CompositorContext::ScopedFrame::Raster(</span><br><span class="line">    flutter::LayerTree&amp; layer_tree,</span><br><span class="line">    <span class="keyword">bool</span> ignore_raster_cache) &#123;</span><br><span class="line">  TRACE_EVENT0(<span class="string">"flutter"</span>, <span class="string">"CompositorContext::ScopedFrame::Raster"</span>);</span><br><span class="line">  <span class="keyword">bool</span> root_needs_readback = layer_tree.Preroll(*<span class="keyword">this</span>, ignore_raster_cache);</span><br><span class="line">  <span class="keyword">bool</span> needs_save_layer = root_needs_readback &amp;&amp; !surface_supports_readback();</span><br><span class="line">  PostPrerollResult post_preroll_result = PostPrerollResult::kSuccess;</span><br><span class="line">  <span class="keyword">if</span> (view_embedder_ &amp;&amp; gpu_thread_merger_) &#123;</span><br><span class="line">    post_preroll_result = view_embedder_-&gt;PostPrerollAction(gpu_thread_merger_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (post_preroll_result == PostPrerollResult::kResubmitFrame) &#123;</span><br><span class="line">    <span class="keyword">return</span> RasterStatus::kResubmit;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Clearing canvas after preroll reduces one render target switch when preroll</span></span><br><span class="line">  <span class="comment">// paints some raster cache.</span></span><br><span class="line">  <span class="keyword">if</span> (canvas()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (needs_save_layer) &#123;</span><br><span class="line">      FML_LOG(INFO) &lt;&lt; <span class="string">"Using SaveLayer to protect non-readback surface"</span>;</span><br><span class="line">      SkRect bounds = SkRect::Make(layer_tree.frame_size());</span><br><span class="line">      SkPaint paint;</span><br><span class="line">      paint.setBlendMode(SkBlendMode::kSrc);</span><br><span class="line">      canvas()-&gt;saveLayer(&amp;bounds, &amp;paint);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas()-&gt;clear(SK_ColorTRANSPARENT);</span><br><span class="line">  &#125;</span><br><span class="line">  layer_tree.Paint(*<span class="keyword">this</span>, ignore_raster_cache); <span class="comment">// 这句是重点</span></span><br><span class="line">  <span class="keyword">if</span> (canvas() &amp;&amp; needs_save_layer) &#123;</span><br><span class="line">    canvas()-&gt;restore();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> RasterStatus::kSuccess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">///layer_tree.cc</span><br><span class="line">void LayerTree::Paint(CompositorContext::ScopedFrame&amp; frame,</span><br><span class="line">                      bool ignore_raster_cache) const &#123;</span><br><span class="line">  TRACE_EVENT0(&quot;flutter&quot;, &quot;LayerTree::Paint&quot;);</span><br><span class="line"></span><br><span class="line">  if (!root_layer_) &#123;</span><br><span class="line">    FML_LOG(ERROR) &lt;&lt; &quot;The scene did not specify any layers to paint.&quot;;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SkISize canvas_size = frame.canvas()-&gt;getBaseLayerSize();</span><br><span class="line">  SkNWayCanvas internal_nodes_canvas(canvas_size.width(), canvas_size.height());</span><br><span class="line">  internal_nodes_canvas.addCanvas(frame.canvas());</span><br><span class="line">  if (frame.view_embedder() != nullptr) &#123;</span><br><span class="line">    auto overlay_canvases = frame.view_embedder()-&gt;GetCurrentCanvases();</span><br><span class="line">    for (size_t i = 0; i &lt; overlay_canvases.size(); i++) &#123;</span><br><span class="line">      internal_nodes_canvas.addCanvas(overlay_canvases[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Layer::PaintContext context = &#123;</span><br><span class="line">      (SkCanvas*)&amp;internal_nodes_canvas,</span><br><span class="line">      frame.canvas(),</span><br><span class="line">      frame.gr_context(),</span><br><span class="line">      frame.view_embedder(),</span><br><span class="line">      frame.context().raster_time(),</span><br><span class="line">      frame.context().ui_time(),</span><br><span class="line">      frame.context().texture_registry(),</span><br><span class="line">      ignore_raster_cache ? nullptr : &amp;frame.context().raster_cache(),</span><br><span class="line">      checkerboard_offscreen_layers_,</span><br><span class="line">      frame_physical_depth_,</span><br><span class="line">      frame_device_pixel_ratio_&#125;;</span><br><span class="line"></span><br><span class="line">  if (root_layer_-&gt;needs_painting())</span><br><span class="line">    root_layer_-&gt;Paint(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 PlatformViewLayer 继承于 flutter::Layer ， 我们聚焦在 PlatformViewLayer</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///Platform_view_layer.cc</span></span><br><span class="line"><span class="keyword">void</span> PlatformViewLayer::Paint(PaintContext&amp; context) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (context.view_embedder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    FML_LOG(ERROR) &lt;&lt; <span class="string">"Trying to embed a platform view but the PaintContext "</span></span><br><span class="line">                      <span class="string">"does not support embedding"</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  SkCanvas* canvas = context.view_embedder-&gt;CompositeEmbeddedView(view_id_);</span><br><span class="line">  context.leaf_nodes_canvas = canvas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///FlutterPlatformviews.mm</span></span><br><span class="line">SkCanvas* FlutterPlatformViewsController::CompositeEmbeddedView(<span class="keyword">int</span> view_id) &#123;</span><br><span class="line">  <span class="comment">// TODO(amirh): assert that this is running on the platform thread once we support the iOS</span></span><br><span class="line">  <span class="comment">// embedded views thread configuration.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do nothing if the view doesn't need to be composited.</span></span><br><span class="line">  <span class="keyword">if</span> (views_to_recomposite_.count(view_id) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> picture_recorders_[view_id]-&gt;getRecordingCanvas();</span><br><span class="line">  &#125;</span><br><span class="line">  CompositeWithParams(view_id, current_composition_params_[view_id]);<span class="comment">//**</span></span><br><span class="line">  views_to_recomposite_.erase(view_id);</span><br><span class="line">  <span class="keyword">return</span> picture_recorders_[view_id]-&gt;getRecordingCanvas();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后终于回到这里 setFrame </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void FlutterPlatformViewsController::CompositeWithParams(int view_id,</span><br><span class="line">                                                         const EmbeddedViewParams&amp; params) &#123;</span><br><span class="line">  CGRect frame = CGRectMake(0, 0, params.sizePoints.width(), params.sizePoints.height());</span><br><span class="line">  UIView* touchInterceptor = touch_interceptors_[view_id].get();</span><br><span class="line">  touchInterceptor.layer.transform = CATransform3DIdentity;</span><br><span class="line">  touchInterceptor.frame = frame; // 就是这里了</span><br><span class="line">  touchInterceptor.alpha = 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>纵观整个调用流程，其中涉及到 由 UI 线程（dart ）切换到 gpu 线程，其中最后的 setFrame 也是在 gpu 线程执行的，而 postFrameCallback 回调是在 dart 层，所以 postFrameCallback 跟 setFrame 并不是在同一个线程，即使按顺序执行下来，setFrame 也不一定比 postFrameCallback 回调执行前先发生。</p>
<p>那 addPostFrameCallback 是不是也就不能解决这个 frame 为 0 的问题了？</p>
<h3 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h3><p>我们都知道， dart 层只有一个线程，而在 engine 层，就不一样了：</p>
<p>当 IsIosEmbeddedViewsPreviewEnabled 为 true 时，</p>
<p> platform  跟 gpu 共用一个线程，且为主线程</p>
<p>i/o 操作独用一个线程</p>
<p>Ui 即 dart 层独用另外一个线程;</p>
<p>其他情况，platform、gpu、i/o, ui 各用一个线程</p>
<p>更多 engine 线程 相关的知识，可以参考这里：<a href="https://zhuanlan.zhihu.com/p/38026271" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38026271</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">///FlutterEngine.mm</span><br><span class="line">if (flutter::IsIosEmbeddedViewsPreviewEnabled()) &#123;</span><br><span class="line"></span><br><span class="line">  flutter::TaskRunners task_runners(threadLabel.UTF8String,                          // label</span><br><span class="line">                                    fml::MessageLoop::GetCurrent().GetTaskRunner(),  // platform</span><br><span class="line">                                    fml::MessageLoop::GetCurrent().GetTaskRunner(),  // gpu</span><br><span class="line">                                    _threadHost.ui_thread-&gt;GetTaskRunner(),          // ui</span><br><span class="line">                                    _threadHost.io_thread-&gt;GetTaskRunner()           // io</span><br><span class="line">  );</span><br><span class="line">  // Create the shell. This is a blocking operation.</span><br><span class="line">  _shell = flutter::Shell::Create(std::move(task_runners),  // task runners</span><br><span class="line">                                  std::move(windowData),    // window data</span><br><span class="line">                                  std::move(settings),      // settings</span><br><span class="line">                                  on_create_platform_view,  // platform view creation</span><br><span class="line">                                  on_create_rasterizer      // rasterzier creation</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> platform  跟 gpu 共用一个线程意味着啥？</p>
<p>意味着，在 addPostFrameCallback 内只要执行的 platform channel 的方法，都可以保证在 setFrame 后再执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WidgetsBinding.instance.addPostFrameCallback((_) &#123;</span><br><span class="line">   FlutterThunder.setRemoteVideoLayout(...);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>兜了一圈，最终的解决方案就是把 frame 相关的代码调用放在 addPostFrameCallback 里面</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Widget _remoteMixinWidget() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_remoteViewWidget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    _remoteViewWidget = FlutterThunder.createNativeView((viewId) &#123;</span><br><span class="line">      remoteViewId = viewId;</span><br><span class="line">      WidgetsBinding.instance.addPostFrameCallback((_) &#123;</span><br><span class="line">         FlutterThunder.setRemoteVideoLayout(...);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, key: _remoteKey);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _remoteViewWidget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终流程如图所示：</p>
<p><img src="http://emyms.bs2dl.yy.com/NTczYmY4NjEtNzRhYS00M2YxLTk4NTMtNzBhODhlMDJkMWQ0.jpg" alt="未命名文件 (5)"></p>
<p>参考：</p>
<blockquote>
<p><a href="https://juejin.im/post/5e6b5b11f265da57187c64bd" target="_blank" rel="noopener">https://juejin.im/post/5e6b5b11f265da57187c64bd</a></p>
<p><a href="https://juejin.im/post/5c24acd5f265da6164141236" target="_blank" rel="noopener">https://juejin.im/post/5c24acd5f265da6164141236</a></p>
<p><a href="http://gityuan.com/2019/06/15/flutter_ui_draw/" target="_blank" rel="noopener">http://gityuan.com/2019/06/15/flutter_ui_draw/</a>   </p>
<p><a href="https://zhuanlan.zhihu.com/p/38026271" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38026271</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/13/physics/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/11/13/physics/" itemprop="url">
                  Flutter 实战系列:个性化 ListView physics
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-13T17:29:00+08:00">
                2019-11-13
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于这篇总结是产品需求驱动的，先简要描述下 Sofanovel 项目的需求：仿照 inkitt 首页，实现个带有 hover 效果的横向列表，我们先直接来看下最后实现效果：<br><img src="http://emyms.bs2dl.yy.com/YjQyYTE4MjUtNzQ2OS00ZWQ3LTlhNGMtNmVkZmY0ZGU2Y2Fm.gif" alt="![](http://emyms.bs2dl.yy.com/MmQzM2UyOTctYjZmMy00NTA5LWE2OTktMzViYmJjNzY1NzM0.gif)![](http://emyms.bs2dl.yy.com/MmQzM2UyOTctYjZmMy00NTA5LWE2OTktMzViYmJjNzY1NzM0.gif)"></p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>这个需求在 iOS 原生的 UIKIt 下 很好解决的，UIScrollView 本来就有个 paging 的属性，来实现这个 “翻页” 效果。而 Flutter 也有个类似的控件 PageView， 我们先来看下 PageView 的实现:</p>
<h3 id="PageView"><a href="#PageView" class="headerlink" title="PageView"></a>PageView</h3><p>普通的 PageView 实现是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">return Container(</span><br><span class="line">  height: 200,</span><br><span class="line">  width: 200,</span><br><span class="line">  child: PageView(</span><br><span class="line">    children: TestDatas.map((color) &#123;</span><br><span class="line">      return Container(</span><br><span class="line">        width: 100,</span><br><span class="line">        height: 200,</span><br><span class="line">        color: color,</span><br><span class="line">      );</span><br><span class="line">    &#125;).toList(),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>效果是 width 永远不受控制，充满屏幕，如图：<br><img src="http://emyms.bs2dl.yy.com/OGQwYjRkZjAtNTMwMy00ZGQwLWEwODQtNTAzMzI1MGU1MTRm.gif" alt></p>
<p>另一种实现：<br>加上 PageController 的 viewportFraction 修饰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">return Container(</span><br><span class="line">  height: 200,</span><br><span class="line">  child: PageView(</span><br><span class="line">    controller: PageController(initialPage: 0, viewportFraction: 0.8),</span><br><span class="line">    children: TestDatas.map((color) &#123;</span><br><span class="line">      return Container(</span><br><span class="line">        width: 100,</span><br><span class="line">        height: 200,</span><br><span class="line">        color: color,</span><br><span class="line">      );</span><br><span class="line">    &#125;).toList(),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>实现效果是这个样子的：<br><img src="http://emyms.bs2dl.yy.com/MmQzM2UyOTctYjZmMy00NTA5LWE2OTktMzViYmJjNzY1NzM0.gif" alt></p>
<p>viewportFraction 这个参数只能粗略地表示 选中区域 占屏幕的百分比，而这个区域永远落在中央，不能简单实现偏左或者偏右的自定义化，因此舍弃了 pageView 的实现。</p>
<h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><h4 id="赋予翻页效果"><a href="#赋予翻页效果" class="headerlink" title="赋予翻页效果"></a>赋予翻页效果</h4><p>从横向布局的 ListView 入手开搞，自定义一个带有 pageView 特性的 physics </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">class PagingScrollPhysics extends ScrollPhysics &#123;</span><br><span class="line">  final double itemDimension; // ListView children item 固定宽度</span><br><span class="line">  final double leadingSpacing; // 选中 item 离左边缘留白</span><br><span class="line">  final double maxSize; // 最大可滑动区域</span><br><span class="line"></span><br><span class="line">  PagingScrollPhysics(</span><br><span class="line">      &#123;this.maxSize,</span><br><span class="line">      this.leadingSpacing,</span><br><span class="line">      this.itemDimension,</span><br><span class="line">      ScrollPhysics parent&#125;)</span><br><span class="line">      : super(parent: parent);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  PagingScrollPhysics applyTo(ScrollPhysics ancestor) &#123;</span><br><span class="line">    return PagingScrollPhysics(</span><br><span class="line">        maxSize: maxSize,</span><br><span class="line">        itemDimension: itemDimension,</span><br><span class="line">        leadingSpacing: leadingSpacing,</span><br><span class="line">        parent: buildParent(ancestor));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  double _getPage(ScrollPosition position, double leading) &#123;</span><br><span class="line">    return (position.pixels + leading) / itemDimension;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  double _getPixels(double page, double leading) &#123;</span><br><span class="line">    return (page * itemDimension) - leading;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  double _getTargetPixels(</span><br><span class="line">    ScrollPosition position,</span><br><span class="line">    Tolerance tolerance,</span><br><span class="line">    double velocity,</span><br><span class="line">    double leading,</span><br><span class="line">  ) &#123;</span><br><span class="line">    double page = _getPage(position, leading);</span><br><span class="line"></span><br><span class="line">    if (position.pixels &lt; 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (position.pixels &gt;= maxSize) &#123;</span><br><span class="line">      return maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (position.pixels &gt; 0) &#123;</span><br><span class="line">      if (velocity &lt; -tolerance.velocity) &#123;</span><br><span class="line">        page -= 0.5;</span><br><span class="line">      &#125; else if (velocity &gt; tolerance.velocity) &#123;</span><br><span class="line">        page += 0.5;</span><br><span class="line">      &#125;</span><br><span class="line">      return _getPixels(page.roundToDouble(), leading);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Simulation createBallisticSimulation(</span><br><span class="line">      ScrollMetrics position, double velocity) &#123;</span><br><span class="line">    // If we&apos;re out of range and not headed back in range, defer to the parent</span><br><span class="line">    // ballistics, which should put us back in range at a page boundary.</span><br><span class="line"></span><br><span class="line">    if ((velocity &lt;= 0.0 &amp;&amp; position.pixels &lt;= position.minScrollExtent))</span><br><span class="line">      return super.createBallisticSimulation(position, velocity);</span><br><span class="line"></span><br><span class="line">    final Tolerance tolerance = this.tolerance;</span><br><span class="line"></span><br><span class="line">    final double target =</span><br><span class="line">        _getTargetPixels(position, tolerance, velocity, leadingSpacing);</span><br><span class="line">    if (target != position.pixels)</span><br><span class="line">      return ScrollSpringSimulation(spring, position.pixels, target, velocity,</span><br><span class="line">          tolerance: tolerance);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool get allowImplicitScrolling =&gt; false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码一大堆，我们聚焦入口 createBallisticSimulation ，这是每次滑动手势结束后会触发，最终都是为了调用下面这句，来产生滑动效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ScrollSpringSimulation(spring, position.pixels, target, velocity,</span><br><span class="line">    tolerance: tolerance);</span><br></pre></td></tr></table></figure>
<p>target 这个参数是整个类的主角，其他辅助函数都是为了计算出这个值而已，target 是表示这次滑动的终点，也就是说，我们通过控制这个参数来控制这次触摸结束后，listview 停在哪里。</p>
<p>其次，构造方法里面里面的 parent 参数也是挺重要的，主要用来组合各种 physics 属性，这里留在后面再说。</p>
<h4 id="选中动效"><a href="#选中动效" class="headerlink" title="选中动效"></a>选中动效</h4><p>这一步无非就是用 scrollView 监听 scroll offset,  到了指定位置就 setState ，已触发选中效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_scrollCtl.addListener(() &#123;</span><br><span class="line">  double test =</span><br><span class="line">      _bookWidth != null ? _scrollCtl.offset / (_bookWidth + margin) : 1;</span><br><span class="line">  int next = test.round();</span><br><span class="line">  if (next &lt; 0) &#123;</span><br><span class="line">    next = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if (next &gt;= testData.length) &#123;</span><br><span class="line">    next = testData.length - 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (_currentPage != next) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _currentPage = next;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">_buildBookItem(Map data, bool active, &#123;num width&#125;) &#123;</span><br><span class="line">  width = _bookWidth;</span><br><span class="line">  // Animated Properties</span><br><span class="line">  final double blur = active ? 5 : 0;</span><br><span class="line">  final double offset = active ? 2 : 0;</span><br><span class="line">  final double top = active ? 10 : 20;</span><br><span class="line">  final double bottom = active ? 10 : 20;</span><br><span class="line"></span><br><span class="line">  return GestureDetector(</span><br><span class="line">    onTap: () &#123;</span><br><span class="line">      if (data[&apos;index&apos;] == _currentPage) &#123;</span><br><span class="line">        _jump();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        scrollToPage(data[&apos;index&apos;]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    child: AnimatedContainer(</span><br><span class="line">      width: width,</span><br><span class="line">      height: 1.38 * width,</span><br><span class="line">      child: Center(child: Text(data[&apos;index&apos;].toString())),</span><br><span class="line">      duration: Duration(milliseconds: 500),</span><br><span class="line">      curve: Curves.easeOutQuint,</span><br><span class="line">      margin: EdgeInsets.only(top: top, bottom: bottom, right: margin),</span><br><span class="line">      decoration: BoxDecoration(</span><br><span class="line">          borderRadius: BorderRadius.circular(4),</span><br><span class="line">          color: randomColor,</span><br><span class="line">          boxShadow: [</span><br><span class="line">            BoxShadow(</span><br><span class="line">                color: Colors.black87,</span><br><span class="line">                blurRadius: blur,</span><br><span class="line">                offset: Offset(offset, offset))</span><br><span class="line">          ]),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>在自测时发现过这样一个问题：当 listView 里面的 children  过少时， 整个 listView 压根不能滑动， physics 里面的 createBallisticSimulation 实现得再完美，也触发不了其中的回调的。为了避免这种情况，比较粗暴的方法是，在 children 加空白 Container，以充满 listView 固有的宽度或者高度，来让 listView 满足可滑动的前提。</p>
<h3 id="正规军解法"><a href="#正规军解法" class="headerlink" title="正规军解法"></a>正规军解法</h3><p>为何 chidren 过少就滑动不了？这里要看下 ScrollPhysics 的源码了，里面有这样一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/// Whether the scrollable should let the user adjust the scroll offset, for</span><br><span class="line">/// example by dragging.</span><br><span class="line">///</span><br><span class="line">/// By default, the user can manipulate the scroll offset if, and only if,</span><br><span class="line">/// there is actually content outside the viewport to reveal.</span><br><span class="line">///</span><br><span class="line">/// The given `position` is only valid during this method call. Do not keep a</span><br><span class="line">/// reference to it to use later, as the values may update, may not update, or</span><br><span class="line">/// may update to reflect an entirely unrelated scrollable.</span><br><span class="line">bool shouldAcceptUserOffset(ScrollMetrics position) &#123;</span><br><span class="line">  if (parent == null)</span><br><span class="line">    return position.pixels != 0.0 || position.minScrollExtent != position.maxScrollExtent;</span><br><span class="line">  return parent.shouldAcceptUserOffset(position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>源码里面注释得很清楚了，唯有内容超出显示范围时，才可以触发他的滚动，即 position.minScrollExtent != position.maxScrollExtent 的时候。<br>所以，我们重载一下这个方法就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">bool shouldAcceptUserOffset(ScrollMetrics position) =&gt; true;</span><br></pre></td></tr></table></figure>
<p>另外，也可以通过构造方法 parent 这个入参去组合多个的已有的 physics 来完成这种特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_physics = PagingScrollPhysics(</span><br><span class="line">        itemDimension: itemWidth,</span><br><span class="line">        leadingSpacing: _leadingPortion,</span><br><span class="line">        maxSize: itemWidth * (testData.length - 1) - _leadingPortion,</span><br><span class="line">        parent: BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics()));</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/Flutter-Overlay/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/07/28/Flutter-Overlay/" itemprop="url">
                  Flutter实战系列: 实现顶级视图可拖动悬浮窗
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-28T15:35:01+08:00">
                2019-07-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><p>这个需求有两个关键点：</p>
<ol>
<li>顶级视图</li>
<li>可拖动</li>
</ol>
<h3 id="涉及-Widget-知识点"><a href="#涉及-Widget-知识点" class="headerlink" title="涉及 Widget 知识点"></a>涉及 Widget 知识点</h3><ol>
<li>Overlay，顶级视图解决方案</li>
<li>Draggable，可拖动解决方案</li>
</ol>
<h4 id="Overlay"><a href="#Overlay" class="headerlink" title="Overlay"></a>Overlay</h4><p>Overlay 之于 Flutter , 有点相当于 KeyWindow 之于 iOS 一样，可以将子 widget 置于其他 widget 的顶层，带来 “悬浮”的效果，具体可见注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// A [Stack] of entries that can be managed independently.</span><br><span class="line">///</span><br><span class="line">/// Overlays let independent child widgets &quot;float&quot; visual elements on top of</span><br><span class="line">/// other widgets by inserting them into the overlay&apos;s [Stack]. The overlay lets</span><br><span class="line">/// each of these widgets manage their participation in the overlay using</span><br><span class="line">/// [OverlayEntry] objects.</span><br><span class="line">/// Rather than creating an overlay, consider using the overlay that is</span><br><span class="line">/// created by the [WidgetsApp] or the [MaterialApp] for the application.</span><br></pre></td></tr></table></figure></p>
<p>文档不建议我们重新初始化一个 overlay 对象 , 最好还是通过 <code>Overlay.of(context)</code>，这样的方式去获取已经存在的 <code>Overlay</code> 对象。</p>
<p>这里就又引出了另外一个新概念 <em>OverlayEntry</em></p>
<h4 id="OverlayEntry"><a href="#OverlayEntry" class="headerlink" title="OverlayEntry"></a>OverlayEntry</h4><p><code>OverlayEntry</code> 之于 <code>Overlay</code>，对于 iOS 开发而言，又有点 subView 之于 KeyWindow 的味道了。 <code>OverlayEntry</code> 是视图的实际的容器， 把其往 <code>Overlay</code> 那儿添加了，就可以成像了。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Creates an overlay entry.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// To insert the entry into an [Overlay], first find the overlay using</span></span><br><span class="line"><span class="comment">/// [Overlay.of] and then call [OverlayState.insert]. To remove the entry,</span></span><br><span class="line"><span class="comment">/// call [remove] on the overlay entry itself.</span></span><br><span class="line">OverlayEntry(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.builder, 		<span class="comment">// builder 模式返回一个 widget</span></span><br><span class="line">    <span class="built_in">bool</span> opaque = <span class="keyword">false</span>,    		<span class="comment">// 是否不透明</span></span><br><span class="line">    <span class="built_in">bool</span> maintainState = <span class="keyword">false</span>,	<span class="comment">// 这个属性与 opaque 有关系，如果某个 entry A的 opaque 被设成 true 了， 那么 overlay 就不去 build 其他在层级在 entry A 以下的 entry 了， 除非 maintainState 设成 true</span></span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(builder != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(opaque != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(maintainState != <span class="keyword">null</span>),</span><br><span class="line">       _opaque = opaque,</span><br><span class="line">       _maintainState = maintainState;</span><br></pre></td></tr></table></figure>
<h4 id="Draggable"><a href="#Draggable" class="headerlink" title="Draggable"></a>Draggable</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const Draggable(&#123;</span><br><span class="line"> Key key,</span><br><span class="line"> @required this.child,				// 初始化显示的 widget</span><br><span class="line"> @required this.feedback,		// 拖拽过程中（活动中）显示的 widget</span><br><span class="line"> this.data,									// widget 携带的数据，放手时可以将这个 data 数据传递出去</span><br><span class="line"> this.axis,									// 限制 draggable 的移动范围</span><br><span class="line"> this.childWhenDragging,			// 拖住动作发生过程中，初始化位置显示的 widget</span><br><span class="line"> this.feedbackOffset = Offset.zero, // 当 feedback 与 child 相比，有 transform 的时候，需要用到这个属性来调整 hittest 范围</span><br><span class="line"> this.dragAnchor = DragAnchor.child, //锚点</span><br><span class="line"> this.affinity,							// 单词的意思是亲和力，当 Draggable 位于 另外一个 Scrollable 控件內时，来控制到底这个这个拖拽事件到底由 Draggable 响应，还是由 Scrollable 控件来响应</span><br><span class="line"> this.maxSimultaneousDrags,	// 限制有多少个 Draggable 同时发生 拖拽动作</span><br><span class="line"> this.onDragStarted,					// 拖拽动作开始回调</span><br><span class="line"> this.onDraggableCanceled,		// 拖拽动作取消回调</span><br><span class="line"> this.onDragEnd,							//拖拽动作结束回调</span><br><span class="line"> this.onDragCompleted,				// 拖拽动作完成回调, 并被一个 DragTarget 接收</span><br><span class="line"> this.ignoringFeedbackSemantics = true, // 也是看了文档才知道，这个属性还是有点用的，当 feedback 跟 child 是同一个 widget A 对象时，就应该把这个属性设成 false, 配合赋值一个 GlobalKey，这样，这个 widget A 就不会在 feedback 跟 child 切换时，重新销毁后又创建了。这个在 widget A 带有播放动画是比较容易看出区别，每次手指拖放都伴随着动画的重新开始</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>一开始只留意到 <code>feedback</code>， <code>childWhenDragging</code>， <code>onDragEnd</code> 几个参数，实际上 <code>ignoringFeedbackSemantics</code> 也是挺重要的，这个放在后面再说。</p>
<p>把我们想要实现拖拽功能的 widget 传到 child 参数位置的时候，跑一下，可以发现，我们已经实现了拖拽功能了，但这个时候，当我们手指离开屏幕的话，child 又自动回到了初始化的位置了，并没有停留在我们想要他停留的位置，为了实现这个功能，我们又得用到另外一个 widget : <code>DragTarget</code></p>
<h4 id="DragTarget"><a href="#DragTarget" class="headerlink" title="DragTarget"></a>DragTarget</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const DragTarget(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  @required this.builder,  //根据 Draggable 传过来的 data ,来显示想要的 widget</span><br><span class="line">  this.onWillAccept,			// 根据传过来的 data ,选择是否接收这个 Draggable， 返回 true 则激活 onAccept</span><br><span class="line">  this.onAccept,					// Draggable 被丢进了这个 DragTarget 区域后回调</span><br><span class="line">  this.onLeave,						// Draggable 离开 DragTarget 区域后的回调</span><br><span class="line">&#125;) : super(key: key);</span><br></pre></td></tr></table></figure>
<p>DragTarget 是用来作为 Draggable 被拖拽结束后接收他的区域,  当然 他可以通过 onWillAccept 的 data ,来选择 接不接收这个 Draggable 。</p>
<p>好了，前面搬文档说了一大堆废话，下面，我们来将这个几个 widget 组合运用起来，实现文章一开始的需求。</p>
<h3 id="组合起来"><a href="#组合起来" class="headerlink" title="组合起来"></a>组合起来</h3><p>关键代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void show(&#123;@required BuildContext context, @required Widget view&#125;) &#123;</span><br><span class="line">  TestOverLay.view = view;</span><br><span class="line"></span><br><span class="line">	//避免重复 show</span><br><span class="line">  remove();</span><br><span class="line">  </span><br><span class="line">  //创建一个OverlayEntry对象</span><br><span class="line">  OverlayEntry overlayEntry = new OverlayEntry(builder: (context) &#123;</span><br><span class="line">  	//通过 Positioned 控制 位置</span><br><span class="line">    return new Positioned(</span><br><span class="line">        top: MediaQuery.of(context).size.height * 0.7,</span><br><span class="line">        child: _buildDraggable(context));</span><br><span class="line">  	&#125;);</span><br><span class="line"></span><br><span class="line">  //往当前 Overlay 中插入 OverlayEntry</span><br><span class="line">  Overlay.of(context).insert(overlayEntry);</span><br><span class="line"></span><br><span class="line">  _holder = overlayEntry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> show 方法无非做了 2 件事：</p>
<ol>
<li>_buildDraggable </li>
<li>创建 OverlayEntry， 并插入到当前上下文的 Overlay</li>
</ol>
<p>再看下 _buildDraggable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static _buildDraggable(context) &#123;</span><br><span class="line">  return new Draggable(</span><br><span class="line">    child: view,										//  child 跟 feedback 用传入同一个 view，这样初始化跟拖拽过程都显示这个 view</span><br><span class="line">    feedback: view,									//</span><br><span class="line">    onDragStarted: () &#123;</span><br><span class="line">       print(&apos;onDragStarted:&apos;);</span><br><span class="line">     &#125;,</span><br><span class="line">	onDragEnd: (detail) &#123;</span><br><span class="line">      print(&apos;onDragEnd:$&#123;detail.offset&#125;&apos;);</span><br><span class="line">      createDragTarget(offset: detail.offset, context: context); // 放手的时候创建一个DragTarget</span><br><span class="line">    &#125;,</span><br><span class="line">    childWhenDragging: Container(), //  这里传个 Container，原来位置啥都不显示</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>放手的时候创建一个 DragTarget对象，用来接收 Draggable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static void createDragTarget(&#123;Offset offset, BuildContext context&#125;) &#123;</span><br><span class="line">  if (_holder != null) &#123;</span><br><span class="line">    _holder.remove();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _holder = new OverlayEntry(builder: (context) &#123;</span><br><span class="line">    bool isLeft = true;</span><br><span class="line">    if (offset.dx + 100 &gt; MediaQuery.of(context).size.width / 2) &#123;</span><br><span class="line">      isLeft = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double maxY = MediaQuery.of(context).size.height - 100;</span><br><span class="line"></span><br><span class="line">    return new Positioned(</span><br><span class="line">        top: offset.dy &lt; 50 ? 50 : offset.dy &lt; maxY ? offset.dy : maxY,</span><br><span class="line">        left: isLeft ? 0 : null,</span><br><span class="line">        right: isLeft ? null : 0,</span><br><span class="line">        child: DragTarget(</span><br><span class="line">          onWillAccept: (data) &#123;</span><br><span class="line">            print(&apos;onWillAccept: $data&apos;);</span><br><span class="line">            return true;</span><br><span class="line">          &#125;,</span><br><span class="line">          onAccept: (data) &#123;</span><br><span class="line">            holded = true;</span><br><span class="line">            print(&apos;onAccept: $data&apos;);</span><br><span class="line">            // refresh();</span><br><span class="line">          &#125;,</span><br><span class="line">          onLeave: (data) &#123;</span><br><span class="line">            print(&apos;onLeave&apos;);</span><br><span class="line">          &#125;,</span><br><span class="line">          builder: (BuildContext context, List incoming, List rejected) &#123;</span><br><span class="line">            return _buildDraggable(context);</span><br><span class="line">          &#125;,</span><br><span class="line">        ));</span><br><span class="line">  &#125;);</span><br><span class="line">  Overlay.of(context).insert(_holder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里也是通过 Positioned 来给 DragTarget 指定位置的，需求对 Draggable 携带的 data 不关心，来者不拒，所以 onWillAccept 那儿直接 return true了；</p>
<p>当接收了 Draggable 后，在 builder 返回想要显示的内容，这里，我们直接返回之前那个 Draggable 对象好了，为下次的拖拽做好准备。</p>
<p>到此为止，整个流程就结束了。</p>
<p>这里看下初步实现效果：<br><img src="/2019/07/28/Flutter-Overlay/image-1564461044-优化前.gif" title="优化前动效"></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>细心的同学可以很容易会发现，每次拖拽动作的开始，结束的时候，view 的旋转动画都会被重置，体验并不友好。看了下日志就知道，在这两个时刻, 都会触发 view 的重建和销毁：</p>
<img src="/2019/07/28/Flutter-Overlay/image-1564461001-优化前log.png" title="优化后log">
<h4 id="ignoringFeedbackSemantics"><a href="#ignoringFeedbackSemantics" class="headerlink" title="ignoringFeedbackSemantics"></a>ignoringFeedbackSemantics</h4><p>文档提示我们，当 <code>Draggable</code> 的 <code>child</code>跟<code>feedback</code>相同时， <code>ignoringFeedbackSemantics = false</code> ，与 <code>GlobalKey</code> 配合使用，可以让 <code>feedback</code> 在 <code>child</code> 切换时，所对应 widget 不被 销毁 和 重新创建，这样设置后，再看下日志</p>
<img src="/2019/07/28/Flutter-Overlay/image-1564461147-优化后log.png" title="优化后log">
<p><code>onDragStated</code>,<code>onDragEnd</code>,虽然也触发了 <code>MiniRoomFloatingWidget</code> 的 <code>build</code> 方法，但并没有销毁及重创建。</p>
<p>在来看下优化后的效果：</p>
<img src="/2019/07/28/Flutter-Overlay/image-1564461330-优化后.gif" title="优化后动效">
<h3 id="最后附上代码"><a href="#最后附上代码" class="headerlink" title="最后附上代码"></a>最后附上代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">class TestOverLay &#123;</span><br><span class="line">  static OverlayEntry _holder;</span><br><span class="line"></span><br><span class="line">  static Widget view;</span><br><span class="line"></span><br><span class="line">  static void remove() &#123;</span><br><span class="line">    if (_holder != null) &#123;</span><br><span class="line">      _holder.remove();</span><br><span class="line">      _holder = null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void show(&#123;@required BuildContext context, @required Widget view&#125;) &#123;</span><br><span class="line">    TestOverLay.view = view;</span><br><span class="line"></span><br><span class="line">    remove();</span><br><span class="line">    //创建一个OverlayEntry对象</span><br><span class="line">    OverlayEntry overlayEntry = new OverlayEntry(builder: (context) &#123;</span><br><span class="line">      return new Positioned(</span><br><span class="line">          top: MediaQuery.of(context).size.height * 0.7,</span><br><span class="line">          child: _buildDraggable(context));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //往Overlay中插入插入OverlayEntry</span><br><span class="line">    Overlay.of(context).insert(overlayEntry);</span><br><span class="line"></span><br><span class="line">    _holder = overlayEntry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static _buildDraggable(context) &#123;</span><br><span class="line">    return new Draggable(</span><br><span class="line">      child: view,</span><br><span class="line">      feedback: view,</span><br><span class="line">      onDragStarted: ()&#123;</span><br><span class="line">        print(&apos;onDragStarted:&apos;);</span><br><span class="line">      &#125;,</span><br><span class="line">      onDragEnd: (detail) &#123;</span><br><span class="line">        print(&apos;onDragEnd:$&#123;detail.offset&#125;&apos;);</span><br><span class="line">        createDragTarget(offset: detail.offset, context: context);</span><br><span class="line">      &#125;,</span><br><span class="line">      childWhenDragging: Container(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void refresh() &#123;</span><br><span class="line">    _holder.markNeedsBuild();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void createDragTarget(&#123;Offset offset, BuildContext context&#125;) &#123;</span><br><span class="line">    if (_holder != null) &#123;</span><br><span class="line">      _holder.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _holder = new OverlayEntry(builder: (context) &#123;</span><br><span class="line">      bool isLeft = true;</span><br><span class="line">      if (offset.dx + 100 &gt; MediaQuery.of(context).size.width / 2) &#123;</span><br><span class="line">        isLeft = false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      double maxY = MediaQuery.of(context).size.height - 100;</span><br><span class="line"></span><br><span class="line">      return new Positioned(</span><br><span class="line">          top: offset.dy &lt; 50 ? 50 : offset.dy &lt; maxY ? offset.dy : maxY,</span><br><span class="line">          left: isLeft ? 0 : null,</span><br><span class="line">          right: isLeft ? null : 0,</span><br><span class="line">          child: DragTarget(</span><br><span class="line">            onWillAccept: (data) &#123;</span><br><span class="line">              print(&apos;onWillAccept: $data&apos;);</span><br><span class="line">              return true;</span><br><span class="line">            &#125;,</span><br><span class="line">            onAccept: (data) &#123;</span><br><span class="line">              print(&apos;onAccept: $data&apos;);</span><br><span class="line">              // refresh();</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave: (data) &#123;</span><br><span class="line">              print(&apos;onLeave&apos;);</span><br><span class="line">            &#125;,</span><br><span class="line">            builder: (BuildContext context, List incoming, List rejected) &#123;</span><br><span class="line">              return _buildDraggable(context);</span><br><span class="line">            &#125;,</span><br><span class="line">          ));</span><br><span class="line">    &#125;);</span><br><span class="line">    Overlay.of(context).insert(_holder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p><a href="https://medium.com/flutter-community/a-deep-dive-into-draggable-and-dragtarget-in-flutter-487919f6f1e4" target="_blank" rel="noopener">https://medium.com/flutter-community/a-deep-dive-into-draggable-and-dragtarget-in-flutter-487919f6f1e4</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/24/Flutter-tabBar一定要居中吗？/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/06/24/Flutter-tabBar一定要居中吗？/" itemprop="url">
                  Flutter: tabBar一定要居中吗？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-24T10:18:05+08:00">
                2019-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><p>flutter 的 tabbar 都是这个样子居中的，<br><img src="/2019/06/24/Flutter-tabBar一定要居中吗？/image-20190624114534451.png" title="充满整行"></p>
<p>能不能不居中呢？<br>一开始对了下那 tabbar api 中的几个属性，</p>
<pre><code>const TabBar({
Key key,
@required this.tabs,
this.controller,
this.isScrollable = false,
this.indicatorColor,
this.indicatorWeight = 2.0,
this.indicatorPadding = EdgeInsets.zero,
this.indicator,
this.indicatorSize,
this.labelColor,
this.labelStyle,
this.labelPadding,
this.unselectedLabelColor,
this.unselectedLabelStyle,
this.dragStartBehavior = DragStartBehavior.start,
this.onTap,}
) 
</code></pre><p>发现通过设置属性是不能达到预想效果，于是，弱弱地走去了人家官网提了个 issue， <a href="https://github.com/flutter/flutter/issues/34539" target="_blank" rel="noopener">can tabBar not centered ?</a>  过了几天，flutter 工程师还加了个这样标签 <a href="https://github.com/flutter/flutter/labels/f%3A%20material%20design" target="_blank" rel="noopener">f: material design</a> <a href="https://github.com/flutter/flutter/labels/framework" target="_blank" rel="noopener">framework</a> ，相当于承认了这个问题？哈哈</p>
<h2 id="自问自答"><a href="#自问自答" class="headerlink" title="自问自答"></a>自问自答</h2><p><code>isScrollable</code> 这个属性默认是 false 的，把他设成 <code>isScrollable = true</code> 后，发现到有个细节改变了，由原来充满这一行的的表现，变成“收敛”了。</p>
<img src="/2019/06/24/Flutter-tabBar一定要居中吗？/image-20190624114534451.png" title="充满整行">
<img src="/2019/06/24/Flutter-tabBar一定要居中吗？/image-20190624114702642.png" title="收敛">
<p>既然每个 tab 都收敛了，那么现在只剩下一个问题了：如何把整个 tabBar 向左对齐？</p>
<p>我第一个想到的是，把 tabBar 用个 container 包裹着，设置下 alignment 不就行了？</p>
<pre><code>Container(
      alignment: Alignment.topLeft,
      child: TabBar(
        labelColor: Colors.black,
        isScrollable: true,
        labelStyle: TextStyle(fontSize: 15, fontWeight: FontWeight.bold),
        unselectedLabelColor: Colors.grey,
        unselectedLabelStyle: TextStyle(fontSize: 11),
        controller: _tabController,
        tabs: tabs.map((e) =&gt; Tab(text: e)).toList(),
      ),
    )
</code></pre><p>是的，指定<code>alignment: Alignment.topLeft</code>这样就可以实现这种效果了</p>
<img src="/2019/06/24/Flutter-tabBar一定要居中吗？/image-20190624115311338.png" title="最终实现">
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>如果需要放在 Scaffold.appBar 里面的话，则需要额外实现 <code>PreferredSizeWidget</code> 这个接口，<code>PreferredSize</code> 这个 widget 就实现了这个接口，我们用 <code>PreferredSize</code> 再包一层,即可。</p>
<p>这里注意一下，<code>preferredSize</code> 这个属性， 并不是用来约束他的 child, 而是当这个组件本身没有设置任何约束时，对自己大小的一种声明。也就是说，如果外部对其是有约束的话，这个属性是用不着的。</p>
<blockquote>
<p>/// The size this widget would prefer if it were otherwise unconstrained.<br>/// A widget with a preferred size.<br>///<br>/// This widget does not impose any constraints on its child, and it doesn’t<br>/// affect the child’s layout in any way. It just advertises a preferred size<br>/// which can be used by the parent.</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/20/helloWorld/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/20/helloWorld/" itemprop="url">
                  C++
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-20T15:59:55+08:00">
                2018-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-1"><a href="#C-1" class="headerlink" title="C ++^1"></a>C ++<a href="为什么我打不出C">^1</a></h1><p><em>尽量不要使用指针和数组，因为太过底层，很可能出现不可预测的问题。尽量使用vector等对其的封装的高级用法。</em></p>
<h2 id="引用-vs-指针"><a href="#引用-vs-指针" class="headerlink" title="引用 vs 指针"></a>引用 vs 指针</h2><p><em>引用</em> 相当于变量的<strong>别名</strong></p>
<pre><code>int ivar = 1;
int &amp;i = ivar;
int *pi = &amp;ivar;

cout &lt;&lt; &quot;i = &quot;&lt;&lt; i &lt;&lt; endl; // 相当于i 为 ivar的别名
cout &lt;&lt; &quot;pi = &quot;&lt;&lt; pi &lt;&lt; endl;
cout &lt;&lt; &quot;*pi = &quot;&lt;&lt; *pi &lt;&lt; endl;
cout &lt;&lt; &quot;&amp;i = &quot;&lt;&lt; &amp;i &lt;&lt; endl;
cout &lt;&lt; &quot;&amp;ivar = &quot;&lt;&lt; &amp;ivar &lt;&lt; endl;
</code></pre><hr>
<p>i = 1<br>pi = 0x7fff5fbff73c<br>*pi = 1<br>&amp;i = 0x7fff5fbff73c</p>
<h2 id="amp-ivar-0x7fff5fbff73c"><a href="#amp-ivar-0x7fff5fbff73c" class="headerlink" title=" &amp;ivar = 0x7fff5fbff73c"></a> &amp;ivar = 0x7fff5fbff73c</h2><p>表明指针就是存放对象<em>地址</em>的地方。</p>
<h2 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h2><pre><code>const int *p = &amp;ivar;
int a = 4;
p = &amp;a;
</code></pre><p>​<br>​        int <em> const conPtr = &ivar;<br>​    
        </em>conPtr  = 4;</p>
<p><em>右边的总和不能变</em></p>
<pre><code>const int * const bothConptr = &amp;ivar;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/12/独立子工程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/12/独立子工程/" itemprop="url">
                  iOS项目部分代码独立子工程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-12T16:04:11+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目在迭代到一定程度的时候，自然而然地，就有需求去将某部分功能的代码独立出来，这也是个必然经过的重构阶段。<br>网上关于这部分的资料其实已经很全了，在这里我就总结一下这方面重构的感悟吧。</p>
<h2 id="mov-files"><a href="#mov-files" class="headerlink" title="mov files"></a>mov files</h2><p>这次commit log最多字眼字眼就是mov files了。一移动文件，svn肯定就有增有减的标记。一开始挺怕删的文件比加进去的多的，所以每次都数一下两者文件数量是否一致。<br>在这个动作之前，肯定肯定会对要操作的文件进行showInFinder，打开了，发现这真是个有趣的地方。<br><em>不同习惯的开发者，创建新文件的风格是不同</em><br>习惯不好的，对xcode的文件结构即使已经分了group了，但show in finder进去一团糟。<br>在这里总结出第一条：<br><em>new file的时候，finder文件结构尽量和xcode目录结构一样，一个文件夹对应一个group</em></p>
<p><em>还有有个小技巧：</em><br>每次改变finder文件结构后，最好都clean一下项目，然后再build,不然有大概率报错找不到头文件。</p>
<h2 id="在子工程里面"><a href="#在子工程里面" class="headerlink" title="在子工程里面"></a>在子工程里面</h2><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>这里应该是最麻烦的地方了。原来在主工程用到mainBundle的地方，通通要改成对应的子bundle。</p>
<h4 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a>bundle</h4><p>创建子工程bundle具体操作如下图<br>上图<br><img src="/2017/06/12/独立子工程/2.jpg" title="new bundle 1"><br><img src="/2017/06/12/独立子工程/3.jpg" title="new bundle 2"><br><img src="/2017/06/12/独立子工程/4.jpg" title="add xib,img to bundle"><br><img src="/2017/06/12/独立子工程/5.jpg" title="add bundle to independece"></p>
<h2 id="在主项目里面"><a href="#在主项目里面" class="headerlink" title="在主项目里面"></a>在主项目里面</h2><h3 id="Build-Settings-user-header-Search-paths"><a href="#Build-Settings-user-header-Search-paths" class="headerlink" title="Build Settings -> user header Search paths"></a>Build Settings -> user header Search paths</h3><img src="/2017/06/12/独立子工程/1.jpg" title="header paths">
<h3 id="Build-Phases-link-binary-with-libaries"><a href="#Build-Phases-link-binary-with-libaries" class="headerlink" title="Build Phases -> link binary with libaries"></a>Build Phases -> link binary with libaries</h3><p>要在这里添加.a文件进去。</p>
<h3 id="Build-Phases-Copy-Bundle-Resources"><a href="#Build-Phases-Copy-Bundle-Resources" class="headerlink" title="Build Phases -> Copy Bundle Resources"></a>Build Phases -> Copy Bundle Resources</h3><p>把子工程的资源文件.bundle添加进去。<br><img src="/2017/06/12/独立子工程/1-1.jpg" title="link binary, copo Bundle"></p>
<h3 id="Build-Phases-Target-Dependencies"><a href="#Build-Phases-Target-Dependencies" class="headerlink" title="Build Phases -> Target Dependencies"></a>Build Phases -> Target Dependencies</h3><p>配置依赖，把在子工程添加进去。这样每次编译的时候，就会先把里面的子工程编译过了，再去搞主工程。没弄这个的话，每次一动子工程什么地方了，必须特定对那个子工程进行build···</p>
<h2 id="子工程加载图片-imageName"><a href="#子工程加载图片-imageName" class="headerlink" title="子工程加载图片 imageName:?"></a>子工程加载图片 imageName:?</h2><p>从上面步骤下来，子工程用代码加载子bundle图片是加载不出来的，特别是iOS7，连xib 都load不出图片来。7以上是可以的。<br>因为直接用imageName：是有问题的,load 出来是nil来的。<br>看api才知道，imageName:是load from main bundle的，对于子bundle，代码要做如下处理</p>
<pre><code>+ (NSString *)resourceName:(NSString *)name withBundleName:(NSString *)bundleName
{
    return [NSString stringWithFormat:@&quot;%@.bundle/%@&quot;, bundleName, name];
}

+ (UIImage *)imageNamed:(NSString *)imageName withBundleName:(NSString *)bundleName
{
    NSBundle *bundle = [self bundleNamed:bundleName];
    if (SystemLessThan(8.0)) {
        NSString *path = [[bundle resourcePath] stringByAppendingPathComponent:imageName];
        UIImage *image = [UIImage imageWithContentsOfFile:path];
        return image;
    }
    else {
        return [UIImage imageNamed:imageName inBundle:bundle compatibleWithTraitCollection:nil];
    }
}

+ (NSArray *)loadNibNamed:(NSString *)name owner:(id)owner withBundleName:(NSString *)bundleName
{
    NSBundle *bundle = [self bundleNamed:bundleName];
    return [bundle loadNibNamed:name owner:owner options:nil];
}

+ (NSBundle *)bundleNamed:(NSString *)bundleName
{
    NSString *bundlePath = [[NSBundle mainBundle] pathForResource:bundleName ofType:@&quot;bundle&quot;];
    return [NSBundle bundleWithPath:bundlePath];
}
</code></pre><p>这里需要特别注意，这个方法无法直接加载image assets里@2x图片，必须逐一把图片拉出来，然后加进bundle里面，才可以成功读取···</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/08/20173-6/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/08/20173-6/" itemprop="url">
                  圆角为何不圆？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-08T14:39:17+08:00">
                2017-06-08
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天遇到了个挺离奇的问题，丫的，设的圆角总是缺了个角。<br>上图<img src="/2017/06/08/20173-6/test.jpg" title="This is an example image"><br>眼看，因为一直感觉总是左边圆缺的那一块，就是右边圆多的那一块，所以一直查代码，觉得原因出在前后两个空间重叠了。<br>到了把两个圆拉到很远了，丫的，还是不圆，我就奔溃了··<br>耗了很久，才发现与画圆角算法无关，是像素点惹的祸！</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>像素对不齐！<br>一开始以为是高度是奇数出问题<br>因为是做全圆角的，所以角度是取1/height,当时height = 21,在retina屏，21*2 = 42,偶数。 其实关系不大。<br>影响效果最大是宽度的值<em>太精确了</em><br>之前之所以一直没遇到过这个问题，莫过于，正常情况下，我们都把宽高写死了，都是用那些很正常的整数吧，自己不会故意把值设成30.78这么奇葩吧···，</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>小数取整，在C语言有几种选择：</p>
<ul>
<li>ceil()</li>
<li>floor()</li>
<li>round()<br>当然选其中的round()来四舍五入了。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/20/1-20/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/20/1-20/" itemprop="url">
                  程序员修炼之路—从小工到专家—读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-20T14:15:55+08:00">
                2017-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>书读了一遍，还在我桌面，希望有空能常翻翻回味回味，有新参透也在这里补充。</p>
<h2 id="破窗子理论"><a href="#破窗子理论" class="headerlink" title="破窗子理论"></a>破窗子理论</h2><p>发现一个bug,或者代码不工整的地方，立马fix好。若留着不修，破窗子会越来越多，这样整个项目会慢慢恶化腐烂下去。</p>
<h2 id="注重交流"><a href="#注重交流" class="headerlink" title="注重交流"></a>注重交流</h2><h2 id="DRY原则-Don’t-Repeat-Yourself"><a href="#DRY原则-Don’t-Repeat-Yourself" class="headerlink" title="DRY原则 Don’t Repeat Yourself"></a>DRY原则 Don’t Repeat Yourself</h2><p>重复分为强加性重复，无意性重复，无耐性重复以及开发人员之间的重复。觉得最容易重复的是无耐性重复，因为相同的动作、需求，去拷贝一个大致相同的函数，修改一些参数去实现类似的功能，看似合理又省事，但的确会留下隐患（将来有改动就得处处改了）。应更多考虑用设计模式来优化代码结构。如项目中WebService 中内聚处理了接口返回码resCode,内聚处理网络错误提示，而不是每次请求都重复去判断resCode == 1；开发人员之间的重复，就涉及代码架构同分工了，最明显的就是重复造轮子，事倍功半。</p>
<h2 id="正交性"><a href="#正交性" class="headerlink" title="正交性"></a>正交性</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>该术语表示某种不相依赖性或者解耦性。如果两个或更多食物中的一个发生变化，不会影响其他事物，这些事物就是正交的。在设计良好的系统中，数据库代码与用户界面是正交的：你可以改动界面，而不影响数据库；更换数据库，而不用改动接界面。</p>
<blockquote>
<p>Eliminate Effects Between Unrelated Things (消除无关事物之间的影响)<br>设计自足（self-contained）的组件:<em>独立</em>，具有<em>单一，良好定义的目的（内聚性）</em>。如果组件是相互隔离的，你就知道你能够改变其中之一，而不用担心其余组件。只要你<em>不改变组件的外部接口</em>，就不会造成波及整个系统的问题。</p>
</blockquote>
<h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><ul>
<li><em>让你的代码保持解耦。</em>编写“羞怯”的代码—就是不会没有必要地向其他模块暴露任何事请、也不依赖其他模块的实现。e.g.如果需要改变对象的状态，让这个对象替你去做，（即让这个对象提供接口，你去调用就可以了），这样，代码就会保持与其他代码的实现的隔离。</li>
<li><em>避免使用全局数据 。</em>（多线程的时候有可能有麻烦）一般而言，所需的任何语境（context）显式地传入模块，代码会更易于理解和维护。</li>
<li><em>避免编写相似的函数。</em>看起来很像的一组函数—他们也许在开始和结束处共享公共的代码，中间的算法却各有不同。重复的代码是结构问题的一种症状。<br>养成不断地<em>批判对待</em>自己代码的习惯，寻找任何重新进行组织，以改善其结构和正交性的机会。 这个过程叫重构。</li>
</ul>
<h2 id="可撤销性"><a href="#可撤销性" class="headerlink" title="可撤销性"></a>可撤销性</h2><blockquote>
<p>there are no final decisions,不存在最终决策。<br>设计灵活的结构去保证需求的变动不至于致命。这样的结构最大的特点是具有正交性，即常说的内部低耦合，层层分离。<br>刚好碰到一个切身相关的例子：这段时间需要将项目的sdk换成欢聚云的sdk,才发现项目之初，就已经把原来用的sdk封装了一层model，再去用。这样巧妙的设计让现在换sdk的时候只需到封装的那层model改就可以了。不然，要是以前一开始就各自为政，随意到处调用sdk的话，就得跑去UI层去处处改就GG了T.T</p>
</blockquote>
<h2 id="拽光弹"><a href="#拽光弹" class="headerlink" title="拽光弹"></a>拽光弹</h2><p><em>主要实现了组件间（模块间）端到端的连接，用以检查你离目标有多远，并在必要的情况下进行调整。</em><br>拽光代码并非用过就扔的代码：你编写它，就是为了保留它。它含有任何一段产品代码都拥有的完整个的错误检查、结构、文档以及自查。只是功能不全而已。<br>虽然简约但是完整，并且构成了最终系统骨架的一部分。</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="what-1"><a href="#what-1" class="headerlink" title="what"></a>what</h3><p>用过就扔的代码，或者就是用笔画出来的草图</p>
<h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><p>可以为下列情况制作原型：</p>
<ul>
<li>架构</li>
<li>已有系统的新功能</li>
<li>外部数据的结构或内存</li>
<li>第三方工具或组件</li>
<li>性能问题</li>
<li>用户界面设计<br><em>原型制作是一种学习经验。其价值并不在于所产生的代码，而在于所学到的经验教训</em></li>
</ul>
<h3 id="how-1"><a href="#how-1" class="headerlink" title="how"></a>how</h3><p>checkList:</p>
<ul>
<li>主要组件的责任是否得到了良好定义?是否恰当？</li>
<li>主要组件间的协作是否得到良好的定义？</li>
<li>耦合是否得意最小化?</li>
<li>能否确定重复的潜在来源？</li>
<li>接口定义和各项约束是否可接受？</li>
<li>每个模块在执行过程中是否能访问到所需的数据？是否能在需要时进行访问？</li>
</ul>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><blockquote>
<p>语言的界限就是一个人世界的界限</p>
</blockquote>
<h2 id="抽时间学习shell"><a href="#抽时间学习shell" class="headerlink" title="抽时间学习shell"></a>抽时间学习shell</h2><h2 id="按合约设计"><a href="#按合约设计" class="headerlink" title="按合约设计"></a>按合约设计</h2><p>简称DBC,软件系统中的每一个函数和方法都会做某件事情。在开始做某事之前，例程对世界的状态可能有某种期望，并且也可能有能力陈述系统结束时的状态。</p>
<ul>
<li>前条件（precondition）。为了调用例程，必须为真的条件。</li>
<li>后条件（postcondition）。例程保证会做的事情。优厚条件这一事实意味着他会结束，不允许无限循环。</li>
<li>类不变项（class invariant）。类确保从调用者的视角来看，该条件总是为真。在例程得内部处理过程中，不变项不一定会保持，但在例程退出、控制返回到调用者时，不变项必须为真。</li>
</ul>
<blockquote>
<p>Design with Contracts.<br>在“正交性”中，我们建议编写“羞怯”的代码。这里，强调的重点是在“懒惰”的代码上：对在开始之前接受的东西要严格，而允诺返回的东西哟啊尽可能少。记住，如果你的合约表明你将接受任何东西，并允诺返回整个世界，那你就有大量代码要写了。</p>
</blockquote>
<h3 id="实现DBC"><a href="#实现DBC" class="headerlink" title="实现DBC"></a>实现DBC</h3><p>在设计时简单地列举<em>输入域的范围</em>是什么、<em>边界条件</em>是什么、<em>例程允诺</em>交付什么，—或者不允诺交付什么。<em>不对这些事项作出陈述，你就回到了靠巧合编程，</em>那是许多项目开始、结束、失败的地方。</p>
<h3 id="谁负责"><a href="#谁负责" class="headerlink" title="谁负责"></a>谁负责</h3><p>谁负责检查前条件，是调用者，还是被调用的例程？如果作为语言的一部分实现，答案是两者都不是：前条件是在调用者调用例程之后，但在进入例程自身之前，在幕后测试的。因而如果要对参数进行任何显示的检查，就必须由调用者来完成。</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><blockquote>
<p>无论何时你发现自己在思考“但那当然不可能发生”，增加代码检查他。最容易的方法是使用断言<br>if it can’t happen, Use Assertions to ensure that it won’t.<br>不仅仅在测试环境打开断言，书中更倾向于生产环境也把断言开着，只把那些特别影响性能的断言关掉。</p>
</blockquote>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul>
<li>fix the problem, Not the Blame</li>
<li>don’t panic,无论上面压力多大，或者dead line多近了，首先保持平常心去调试bug。</li>
<li>责任别外卸, bug 有可能存在于OS、编译器、或是第三方库，但这不应该是你的第一想法。有大得多的可能性的是，bug就存在于正在开发的代码中。</li>
<li>重现bug,无须弄太多复杂人工操作，有时候一句代码就可以重现了。</li>
<li>跟反馈人员面谈，搜集更多的数据</li>
<li>必须强硬地测试<em>边界条件</em>。</li>
<li><em>不要假定，要证明！</em></li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="什么是异常情况"><a href="#什么是异常情况" class="headerlink" title="什么是异常情况"></a>什么是异常情况</h3><p>异常很少应作为程序的正常流程的一部分使用；异常应保留给意外事件。假定某个未被抓住的异常会终止你的程序了，问问你自己：“如果移走所有的异常处理器，这些代码是否仍然能运行？”如果答案是“否”，那么异常也许就正在被用在非异常的情形中。<br>e.g. 你的代码试图打开一个文件进行读取，而该文件并不存在，是否应该引发异常，这里分2种情况讨论：</p>
<ol>
<li>如果你确定文件就应该在哪里，那么引发异常就有正当理由。</li>
<li>你不确定文件是否存在，也就找不到文件看来就不是异常情况了，这里适合用错误返回。<blockquote>
<p>Use Exceptions for Exceptional Problems.<br>异常表示即时的、非局部的控制转移。<br>如果把异常当成正常流程处理的话，代码的可读性和可维护性将受到打击。</p>
</blockquote>
</li>
</ol>
<h3 id="OC有-try-catch-有异常处理机制，为什么业界好像不怎么推荐使用？"><a href="#OC有-try-catch-有异常处理机制，为什么业界好像不怎么推荐使用？" class="headerlink" title="OC有@try @catch 有异常处理机制，为什么业界好像不怎么推荐使用？"></a>OC有@try @catch 有异常处理机制，为什么业界好像不怎么推荐使用？</h3><ol>
<li>因为try catch无法捕获UncaughtException，而OC中大部分crash如：<em>内存溢出、野指针等都是无法捕获的</em>，而能捕获的只是像数组越界之类（这真心需要catch么？注：完全可以通过代码判断避免），所以try catch对于OC来说，比较鸡肋。</li>
<li>简单的来说，Apple虽然同时提供了错误处理（NSError）和异常处理（exception）两种机制，但是Apple更加提倡开发者使用NSError来处理程序运行中可恢复的错误。而异常被推荐用来处理不可恢复的错误。    原因有几个，在非gc情况下，exception容易造成内存管理问题（文档有描述即使是arc下，也不是安全的）；exception使用block造成额外的<em>开销</em>，<em>效率较低</em>等等，另外这也的确是Cocoa开发者的习惯。</li>
<li>很多人在编程中，错误了使用了Try-Catch，把异常处理机制用在了核心逻辑中。把其当成了一个变种的GOTO使用。把大量的逻辑写在了Catch中。弱弱的说一句，这种情况干嘛不用ifelse呢。<br>综上3点原因，建议大家还是在代码中少用，可以通过判断是否非空、判断数组是否越界等方法进行处理。但是如果需要在代码中处理一些异常，也是可以的。</li>
</ol>
<h3 id="错误处理器"><a href="#错误处理器" class="headerlink" title="错误处理器"></a>错误处理器</h3><p>错误处理器是检测到错误调用的例程。</p>
<h2 id="配平资源"><a href="#配平资源" class="headerlink" title="配平资源"></a>配平资源</h2><p>e.g-》p105 遵循谁打开，谁关闭，谁分配，谁释放原则。与iOS早期的MRC思想一样。</p>
<h3 id="嵌套的分配"><a href="#嵌套的分配" class="headerlink" title="嵌套的分配"></a>嵌套的分配</h3><ol>
<li>以与资源分配次序想法的次序解除资源的分配。（reverse）</li>
<li>在代码不同的地方分配同一组资源时，总是以相同的次序分配他们。（有效降低死锁）</li>
</ol>
<h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><blockquote>
<p>保持灵活的一种方法是少写代码。改动代码会使你引入新bug的可能性增大。<br>个人觉得减少重复，减少硬编码的意思。<br>把你的代码组织成最小组织单位（模块），并限制他们的交互。</p>
</blockquote>
<h3 id="函数的得墨忒耳定律"><a href="#函数的得墨忒耳定律" class="headerlink" title="函数的得墨忒耳定律"></a>函数的得墨忒耳定律</h3><blockquote>
<p>Minimize Coupling Between Modules<br>百科了一下<br>很多面向对象程序设计语言用”.”表示对象的域的解析算符，因此得墨忒耳定律可以简单地陈述为“只使用一个.算符”。因此，a.b.Method()违反了此定律，而a.Method()不违反此定律。一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。</p>
</blockquote>
<pre><code>public void show Balance (BankAccount acct) 
{
   Money amt = acct.getBalance();
   printToScreen(amt.printFormat());
}
</code></pre><p>acct 为传入参数对象，可以调用acc.getBalance(),但amt.printFormat()就相当于acc.getBalance().printFormat(), 即a.b.Method(),违反了得墨忒耳定律，因此，可略去中间Money对象，直接在BankAccount中新增个printBalance()方法即可。</p>
<pre><code>public void show Balance (BankAccount acct) 
{
   acct.pintBalance();
}
</code></pre><p>实践中，其实就意味着编写大量的包装方法，让一个包工头类将请求转发给下面的分工。</p>
<blockquote>
<p>一句话就是模块之间仅仅暴露<em>有限 关键</em>信息，作<em>最少</em>交互。</p>
</blockquote>
<h2 id="元程序设计"><a href="#元程序设计" class="headerlink" title="元程序设计"></a>元程序设计</h2><h3 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h3><p>使系统变得高度可配置，用元数据描述应用的配置选项。（这里说得有点像OSX 的系统偏好设置吧？）</p>
<h3 id="元数据驱动的应用"><a href="#元数据驱动的应用" class="headerlink" title="元数据驱动的应用"></a>元数据驱动的应用</h3><blockquote>
<p>put Abstractions in Code, Details in Metadata</p>
</blockquote>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><blockquote>
<p>Always Design for Concurrency<br>本书对并发非常看重，还给了个将流程工作向并发操作的小tips:<br>Analyze Workflow to Improve Concurrency<br>将需求流程转化为UML图，其中没有指入箭头的项目可以考虑并发操作。</p>
</blockquote>
<h2 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h2><h2 id="靠巧合编程"><a href="#靠巧合编程" class="headerlink" title="靠巧合编程"></a>靠巧合编程</h2><p>要清楚，我们身处雷区，如果依靠巧合编程，就如同在雷区碰运气排雷一样，随时爆炸身亡了。<br>这个雷我上个月就踩过。<br>当时意识不够，没意识到线上环境是如此大凶险的，擅自用uid为key存储数据了。在开发这个版本的时候，一直没出问题，想当然地认为产品上线也会顺顺利利的，殊不知，在n个版本之前，已经有同事用过uid来存储另一种类型的数据了，尽管这个数据早在版本迭代中废弃没用了，但一直存在与用户机器中。而OC 恰恰又是动态语言，不管你代码写他是什么，数据类型要到运行时才能确定···。<br>种种巧合在这个时间点堆砌起来，bang的一声，就这样炸开了。</p>
<h3 id="怎么巧合编程"><a href="#怎么巧合编程" class="headerlink" title="怎么巧合编程"></a>怎么巧合编程</h3><p>好了，言归正传，巧合编程主要包括实现的偶然性，语境的偶然性和隐含的假定。<br>当初我犯了实现的偶然性和隐含的假定。假定了在我之前没人用过uid作key存过数据，况且既然版本测试没问题了，就真的没问题了。</p>
<h3 id="怎样深思熟虑地编程"><a href="#怎样深思熟虑地编程" class="headerlink" title="怎样深思熟虑地编程"></a>怎样深思熟虑地编程</h3><ul>
<li>总是意识到你在做什么</li>
<li>不要盲目地编程，使用不熟悉，不理解的第三方库，技术等</li>
<li>按照计划行事</li>
<li>依靠可靠的事物。不要依靠<em>巧合</em>或<em>假定</em>。</li>
<li>为你的假设建立文档。有助于澄清假定，并传递给他人。</li>
<li>不要只测试你的代码，还要测试你的假定。尝试<em>证明</em>假定。</li>
<li>为工作划分优先级。把时间花在重要的方面</li>
<li>不要做历史的奴隶。不要让已有的代码支配将来的代码。如果不再适用，所有的代码都应该替换。</li>
</ul>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><h3 id="when："><a href="#when：" class="headerlink" title="when："></a>when：</h3><ul>
<li>重复。当发现违反DRY原则的时候。</li>
<li>非正交设计</li>
<li>过时的知识</li>
<li>性能</li>
</ul>
<h3 id="why"><a href="#why" class="headerlink" title="why:"></a>why:</h3><p>  把需要重构的代码当做是一种“肿瘤”，你现在可以手术，趁它还小把它取出来，你也可以等他增大并扩散—但那时再切除它就会更昂贵、更危险。等再久一些，“病人”就有可能会丧命。</p>
<h3 id="how-2"><a href="#how-2" class="headerlink" title="how:"></a>how:</h3><ul>
<li>不要试图在重构的同时新增功能。</li>
<li>在开始重构之前，确保你拥有<em>良好的测试</em>。尽可能经常运行这些测试。这样，如果你的改动破坏了任何东西，你就能很快知道。</li>
<li>采取<em>短小、深思熟虑</em>的步骤：把某个字段从一个类移往另一个，把两个类似的方法融合进超类中。重构常常设计到进行许多局部改动，继而产生更大规模的改动。如果你使你的步骤保持短小，并在每个步骤之后进行测试，你能够后期避免长时间的调试。</li>
<li>看到不怎么合理的代码时，既要修正他，也要修正依赖于他的每样东西</li>
<li><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2></li>
</ul>
<h3 id="what-2"><a href="#what-2" class="headerlink" title="what"></a>what</h3><p>在隔离状态下，对每个模块进行测试，目的是检验其行为。<br>软件的单元测试，是指对模块进行演练的代码。</p>
<h3 id="how-3"><a href="#how-3" class="headerlink" title="how"></a>how</h3><p>编写测试代码，确保给定的单元遵守其合约。通过广泛的测试用例与边界条件，测试模块是否实现了它允诺的功能。<br>测试模块之间相互依赖的情况：<br>依赖于LinkedList 和 Sort 的模块 A</p>
<ol>
<li>全面测试Linklist的合约</li>
<li>全面测试Sort的合约</li>
<li>测试A的合约，它依赖于另外两个合约，但没有直接暴露他们。<br>这种风格的测试要求你首先测试模块的子组件。一旦子组件得到了检验，就可以测试模块本身。</li>
</ol>
<p>之前听过很多大牛的分享，都很强烈使用单元测试。我们项目是否也考虑下引入？</p>
<h2 id="before-the-Project-在项目开始之前"><a href="#before-the-Project-在项目开始之前" class="headerlink" title="before the Project 在项目开始之前"></a>before the Project 在项目开始之前</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>需求很少存在于表面上。通常，他们深深埋藏在层层假定、误解和政治手段的下面<br>Don’t gather requirements - Dig for them</p>
<h4 id="挖掘需求"><a href="#挖掘需求" class="headerlink" title="挖掘需求"></a>挖掘需求</h4><p>Work with a User to think like a User</p>
<h3 id="建立需求文档"><a href="#建立需求文档" class="headerlink" title="建立需求文档"></a>建立需求文档</h3><p>当遇到一些合适的、描述应用需要做什么的情景，把它们写下来，并发布，每个人都可以以此为据用作讨论的基础文档—开发者、最终用户、以及项目出资人。</p>
<h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><p>可以用UML活动图捕捉工作流，而且有时要为手边的事务建模。概念图很有用，但真正的用例是具有<em>层次结构</em>和<em>交叉链接</em>的文字描述，用例间可以互相嵌套。</p>
<h4 id="规定过度"><a href="#规定过度" class="headerlink" title="规定过度"></a>规定过度</h4><p>制作需求文档的一大危险是太过具体，好的需求文档会保持抽象，在涉及需求的地方，<em>最简单的、能准确</em>地反应商业需求的陈述是最好的。这并非意味着可以含糊不清—你必须把底层的语意不变项当做需求进行捕捉，并把及的或当前的工作实践当做政策记入文档。<br>  <em>需求不是架构，需求不是设计，也不是用户界面</em></p>
<h4 id="维护词汇表"><a href="#维护词汇表" class="headerlink" title="维护词汇表"></a>维护词汇表</h4><p>一旦开始讨论需求，用户和领域专家就会使用对他们有特定含义的属于。e.g.“客户”和“顾客”。<br>  要创建并维护项目词汇表（project glossary）—定义项目中使用专业术语的地方。项目的所有参与者，从最终用户到设计人员，都应该使用这个词汇表，以确保<strong>一致性</strong>。</p>
<h4 id="把项目文档发布到内网上"><a href="#把项目文档发布到内网上" class="headerlink" title="把项目文档发布到内网上"></a>把项目文档发布到内网上</h4><h2 id="解开不可能解开的谜题"><a href="#解开不可能解开的谜题" class="headerlink" title="解开不可能解开的谜题"></a>解开不可能解开的谜题</h2><p>秘诀是确定真正的（而不是想象的）约束，并在其中找出解决方法。有些约束是绝对的；有些则只是<em>先入之见</em>。</p>
<blockquote>
<p>Don’t think Outside the Box — find the box.</p>
</blockquote>
<h2 id="是良好的判断，还是拖延？"><a href="#是良好的判断，还是拖延？" class="headerlink" title="是良好的判断，还是拖延？"></a>是良好的判断，还是拖延？</h2><p><em>构建原型</em>，选择一个你觉得会有困难的地方，开始进行某种“概念验证”。在典型情况下，可能会发生两种情况：</p>
<ol>
<li>开始不久，就觉得自己再浪费时间，这种厌烦可能很好标明了，你最初的勉强只是希望推迟启动。—》<em>放弃原型，回到真正的开发中</em></li>
<li>随着原型取得进展，可能得到启示：突然意识到有些基本的前提错了。不仅如此，你还清楚的看到可以怎样纠正错误。—》愉快地放弃原型，投入正常的项目。<br>当你做出决定把<em>构建原型</em>当作调查你的不适的一种方法时，一定要记住<strong>为何这样做</strong>。</li>
</ol>
<h2 id="规范陷阱"><a href="#规范陷阱" class="headerlink" title="规范陷阱"></a>规范陷阱</h2><p>编写程序规范就是把需求规约到程序员能够接管的程度的过程。这是个交流活动，旨在解释并澄清系统的需求。</p>
<p><em>没有给编码者留下任何解释余地的设计会剥夺了他们发挥技巧和艺术才能的权利。</em></p>
<h2 id="圆圈与箭头"><a href="#圆圈与箭头" class="headerlink" title="圆圈与箭头"></a>圆圈与箭头</h2><blockquote>
<p>Don’t be a slave to Formal Methods<br>Expensive TOOls do not Produce Better Designs<br><em>注重实效的程序员</em>批判的看待方法学，并从各种方法学中提取精华，融合成一套工作习惯。<br>你应该不断努力提炼和改善你的开发过程。绝不要把方法学的代办限制当做你的世界的边界。</p>
</blockquote>
<h2 id="注重实效的项目"><a href="#注重实效的项目" class="headerlink" title="注重实效的项目"></a>注重实效的项目</h2><p>一旦参与项目的人员超过一个，你就需要建立一些基本原则，并相应地分派任务。</p>
<h3 id="注重实效的团队"><a href="#注重实效的团队" class="headerlink" title="注重实效的团队"></a>注重实效的团队</h3><h4 id="不要留破窗户"><a href="#不要留破窗户" class="headerlink" title="不要留破窗户"></a>不要留破窗户</h4><h4 id="煮青蛙"><a href="#煮青蛙" class="headerlink" title="煮青蛙"></a>煮青蛙</h4><p>确保每个人主动监视环境的变化—监视好任何不在最初约定中的东西。</p>
<h4 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h4><h4 id="DRY"><a href="#DRY" class="headerlink" title="DRY"></a>DRY</h4><h4 id="正交性-1"><a href="#正交性-1" class="headerlink" title="正交性"></a>正交性</h4><p>按照功能划分团队。让各团队按照个人的能力，在内部自行进行组织。每个团队都按照他们约定的承诺，对项目中的其他团队富有责任。<br>我们是在需求内聚的、在很大程序上自足的团队—和使代码模块化是使用的标准完全一样</p>
<h4 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h4><ul>
<li>一切都要自动化_<br>don’t use manual Procedure<br>使用shell脚本，cron自动化工具</li>
<li>项目编译<br>makefile</li>
<li>生成代码</li>
<li>回归测试</li>
</ul>
<h3 id="无情的测试"><a href="#无情的测试" class="headerlink" title="无情的测试"></a>无情的测试</h3><p>开发过程中就要找到自己的bug,以免以后经受由他人找到我们的不过所带来的羞耻。</p>
<blockquote>
<p>test early, test often, test automatically.<br>好的项目拥有的测试代码可能比产品代码还要多。<br>coding ain’t done till all the tests run</p>
</blockquote>
<h4 id="what-3"><a href="#what-3" class="headerlink" title="what"></a>what</h4><ul>
<li>单元测试</li>
<li>集成测试</li>
<li>验证和校验</li>
<li>资源耗尽、错误及恢复</li>
<li>性能测试</li>
<li>可用性测试</li>
</ul>
<h5 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h5><p>对某个模块进行演练的代码</p>
<h5 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h5><p>检测多个模块所组成的系统的集成问题</p>
<h5 id="验证和校验"><a href="#验证和校验" class="headerlink" title="验证和校验"></a>验证和校验</h5><p>是否用户所需？是否满足系统的功能需求？</p>
<h5 id="资源耗尽、错误及恢复"><a href="#资源耗尽、错误及恢复" class="headerlink" title="资源耗尽、错误及恢复"></a>资源耗尽、错误及恢复</h5><p>代码可能遇到的一些限制包括：</p>
<ul>
<li>内存空间</li>
<li>磁盘空间</li>
<li>CPU带宽</li>
<li>挂钟时间</li>
<li>磁盘带宽</li>
<li>网络带宽</li>
<li>调色板</li>
<li>视频分辨率<h5 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h5></li>
<li>性能测试</li>
<li>压力测试</li>
<li>负载测试<br>是否满足一下的性能需求— 预期的用户数、连接数、或每秒的事务数？<h4 id="how-4"><a href="#how-4" class="headerlink" title="how"></a>how</h4><h5 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h5>把当前测试的输出与之前的（或已知的）进行对比。确认今天修的bug没有破坏昨天的代码。<h5 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h5></li>
<li>大量</li>
<li>强调边界条件</li>
<li>具有特定统计属性的数据<h5 id="演练GUI系统"><a href="#演练GUI系统" class="headerlink" title="演练GUI系统"></a>演练GUI系统</h5></li>
</ul>
<h5 id="对测试进行测试"><a href="#对测试进行测试" class="headerlink" title="对测试进行测试"></a>对测试进行测试</h5><blockquote>
<p>use Saboteurs to test your Testing<br>故意引入bug,并证实测试能抓住他们</p>
</blockquote>
<h5 id="彻底测试"><a href="#彻底测试" class="headerlink" title="彻底测试"></a>彻底测试</h5><blockquote>
<p>test state Coverage, Not code Cerage<br>测试尝试去覆盖所有代码的状态。</p>
</blockquote>
<h4 id="when-1"><a href="#when-1" class="headerlink" title="when"></a>when</h4><p>任何产品代码一旦存在，就需要进行测试<br>大多数测试都应该自动完成。<br>一旦测试人员找到了某个bug,应该对自动化测试进行修改，从此每次都自动化的检查那个特定的bug</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>为项目制作的文档基本上有两种：内部文档和外部文档。</p>
<h3 id="内部文档"><a href="#内部文档" class="headerlink" title="内部文档"></a>内部文档</h3><h4 id="代码中的注释"><a href="#代码中的注释" class="headerlink" title="代码中的注释"></a>代码中的注释</h4><p>注释应该讨论为何做某事、它的目的和目标（因为代码已经说明他是怎么完成的）。<br>我们喜欢看到见得模块级头注释、关于重要数据与类型的注释、以及给每个类和没个方法所加的简要头注释，用以描述函数的<em>用法</em>和<em>任何不明了的</em>事情。 </p>
<h2 id="傲慢与偏见"><a href="#傲慢与偏见" class="headerlink" title="傲慢与偏见"></a>傲慢与偏见</h2><blockquote>
<p>注重实效的程序员不会逃避责任。相反，我们乐于接受挑战，乐于是我们的专业知识广为人知。<br>不应该怀着猜忌心组织要查看你的代码的人；出于同样的原因，你应该带着尊重对待他人的代码。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Terrence">
          <p class="site-author-name" itemprop="name">Terrence</p>
          <p class="site-description motion-element" itemprop="description">上帝只救自救者</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Terrence</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  




  
  

  

  

  

  


</body>
</html>
