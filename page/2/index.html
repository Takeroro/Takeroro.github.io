<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="上帝只救自救者">
<meta property="og:type" content="website">
<meta property="og:title" content="I&#39;m Terrence">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="I&#39;m Terrence">
<meta property="og:description" content="上帝只救自救者">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="I&#39;m Terrence">
<meta name="twitter:description" content="上帝只救自救者">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title> I'm Terrence </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">I'm Terrence</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/08/20173-6/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/08/20173-6/" itemprop="url">
                  圆角为何不圆？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-08T14:39:17+08:00">
                2017-06-08
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天遇到了个挺离奇的问题，丫的，设的圆角总是缺了个角。<br>上图<img src="/2017/06/08/20173-6/test.jpg" title="This is an example image"><br>眼看，因为一直感觉总是左边圆缺的那一块，就是右边圆多的那一块，所以一直查代码，觉得原因出在前后两个空间重叠了。<br>到了把两个圆拉到很远了，丫的，还是不圆，我就奔溃了··<br>耗了很久，才发现与画圆角算法无关，是像素点惹的祸！</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>像素对不齐！<br>一开始以为是高度是奇数出问题<br>因为是做全圆角的，所以角度是取1/height,当时height = 21,在retina屏，21*2 = 42,偶数。 其实关系不大。<br>影响效果最大是宽度的值<em>太精确了</em><br>之前之所以一直没遇到过这个问题，莫过于，正常情况下，我们都把宽高写死了，都是用那些很正常的整数吧，自己不会故意把值设成30.78这么奇葩吧···，</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>小数取整，在C语言有几种选择：</p>
<ul>
<li>ceil()</li>
<li>floor()</li>
<li>round()<br>当然选其中的round()来四舍五入了。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/20/1-20/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/20/1-20/" itemprop="url">
                  程序员修炼之路—从小工到专家—读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-20T14:15:55+08:00">
                2017-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>书读了一遍，还在我桌面，希望有空能常翻翻回味回味，有新参透也在这里补充。</p>
<h2 id="破窗子理论"><a href="#破窗子理论" class="headerlink" title="破窗子理论"></a>破窗子理论</h2><p>发现一个bug,或者代码不工整的地方，立马fix好。若留着不修，破窗子会越来越多，这样整个项目会慢慢恶化腐烂下去。</p>
<h2 id="注重交流"><a href="#注重交流" class="headerlink" title="注重交流"></a>注重交流</h2><h2 id="DRY原则-Don’t-Repeat-Yourself"><a href="#DRY原则-Don’t-Repeat-Yourself" class="headerlink" title="DRY原则 Don’t Repeat Yourself"></a>DRY原则 Don’t Repeat Yourself</h2><p>重复分为强加性重复，无意性重复，无耐性重复以及开发人员之间的重复。觉得最容易重复的是无耐性重复，因为相同的动作、需求，去拷贝一个大致相同的函数，修改一些参数去实现类似的功能，看似合理又省事，但的确会留下隐患（将来有改动就得处处改了）。应更多考虑用设计模式来优化代码结构。如项目中WebService 中内聚处理了接口返回码resCode,内聚处理网络错误提示，而不是每次请求都重复去判断resCode == 1；开发人员之间的重复，就涉及代码架构同分工了，最明显的就是重复造轮子，事倍功半。</p>
<h2 id="正交性"><a href="#正交性" class="headerlink" title="正交性"></a>正交性</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>该术语表示某种不相依赖性或者解耦性。如果两个或更多食物中的一个发生变化，不会影响其他事物，这些事物就是正交的。在设计良好的系统中，数据库代码与用户界面是正交的：你可以改动界面，而不影响数据库；更换数据库，而不用改动接界面。</p>
<blockquote>
<p>Eliminate Effects Between Unrelated Things (消除无关事物之间的影响)<br>设计自足（self-contained）的组件:<em>独立</em>，具有<em>单一，良好定义的目的（内聚性）</em>。如果组件是相互隔离的，你就知道你能够改变其中之一，而不用担心其余组件。只要你<em>不改变组件的外部接口</em>，就不会造成波及整个系统的问题。</p>
</blockquote>
<h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><ul>
<li><em>让你的代码保持解耦。</em>编写“羞怯”的代码—就是不会没有必要地向其他模块暴露任何事请、也不依赖其他模块的实现。e.g.如果需要改变对象的状态，让这个对象替你去做，（即让这个对象提供接口，你去调用就可以了），这样，代码就会保持与其他代码的实现的隔离。</li>
<li><em>避免使用全局数据 。</em>（多线程的时候有可能有麻烦）一般而言，所需的任何语境（context）显式地传入模块，代码会更易于理解和维护。</li>
<li><em>避免编写相似的函数。</em>看起来很像的一组函数—他们也许在开始和结束处共享公共的代码，中间的算法却各有不同。重复的代码是结构问题的一种症状。<br>养成不断地<em>批判对待</em>自己代码的习惯，寻找任何重新进行组织，以改善其结构和正交性的机会。 这个过程叫重构。</li>
</ul>
<h2 id="可撤销性"><a href="#可撤销性" class="headerlink" title="可撤销性"></a>可撤销性</h2><blockquote>
<p>there are no final decisions,不存在最终决策。<br>设计灵活的结构去保证需求的变动不至于致命。这样的结构最大的特点是具有正交性，即常说的内部低耦合，层层分离。<br>刚好碰到一个切身相关的例子：这段时间需要将项目的sdk换成欢聚云的sdk,才发现项目之初，就已经把原来用的sdk封装了一层model，再去用。这样巧妙的设计让现在换sdk的时候只需到封装的那层model改就可以了。不然，要是以前一开始就各自为政，随意到处调用sdk的话，就得跑去UI层去处处改就GG了T.T</p>
</blockquote>
<h2 id="拽光弹"><a href="#拽光弹" class="headerlink" title="拽光弹"></a>拽光弹</h2><p><em>主要实现了组件间（模块间）端到端的连接，用以检查你离目标有多远，并在必要的情况下进行调整。</em><br>拽光代码并非用过就扔的代码：你编写它，就是为了保留它。它含有任何一段产品代码都拥有的完整个的错误检查、结构、文档以及自查。只是功能不全而已。<br>虽然简约但是完整，并且构成了最终系统骨架的一部分。</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="what-1"><a href="#what-1" class="headerlink" title="what"></a>what</h3><p>用过就扔的代码，或者就是用笔画出来的草图</p>
<h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><p>可以为下列情况制作原型：</p>
<ul>
<li>架构</li>
<li>已有系统的新功能</li>
<li>外部数据的结构或内存</li>
<li>第三方工具或组件</li>
<li>性能问题</li>
<li>用户界面设计<br><em>原型制作是一种学习经验。其价值并不在于所产生的代码，而在于所学到的经验教训</em></li>
</ul>
<h3 id="how-1"><a href="#how-1" class="headerlink" title="how"></a>how</h3><p>checkList:</p>
<ul>
<li>主要组件的责任是否得到了良好定义?是否恰当？</li>
<li>主要组件间的协作是否得到良好的定义？</li>
<li>耦合是否得意最小化?</li>
<li>能否确定重复的潜在来源？</li>
<li>接口定义和各项约束是否可接受？</li>
<li>每个模块在执行过程中是否能访问到所需的数据？是否能在需要时进行访问？</li>
</ul>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><blockquote>
<p>语言的界限就是一个人世界的界限</p>
</blockquote>
<h2 id="抽时间学习shell"><a href="#抽时间学习shell" class="headerlink" title="抽时间学习shell"></a>抽时间学习shell</h2><h2 id="按合约设计"><a href="#按合约设计" class="headerlink" title="按合约设计"></a>按合约设计</h2><p>简称DBC,软件系统中的每一个函数和方法都会做某件事情。在开始做某事之前，例程对世界的状态可能有某种期望，并且也可能有能力陈述系统结束时的状态。</p>
<ul>
<li>前条件（precondition）。为了调用例程，必须为真的条件。</li>
<li>后条件（postcondition）。例程保证会做的事情。优厚条件这一事实意味着他会结束，不允许无限循环。</li>
<li>类不变项（class invariant）。类确保从调用者的视角来看，该条件总是为真。在例程得内部处理过程中，不变项不一定会保持，但在例程退出、控制返回到调用者时，不变项必须为真。</li>
</ul>
<blockquote>
<p>Design with Contracts.<br>在“正交性”中，我们建议编写“羞怯”的代码。这里，强调的重点是在“懒惰”的代码上：对在开始之前接受的东西要严格，而允诺返回的东西哟啊尽可能少。记住，如果你的合约表明你将接受任何东西，并允诺返回整个世界，那你就有大量代码要写了。</p>
</blockquote>
<h3 id="实现DBC"><a href="#实现DBC" class="headerlink" title="实现DBC"></a>实现DBC</h3><p>在设计时简单地列举<em>输入域的范围</em>是什么、<em>边界条件</em>是什么、<em>例程允诺</em>交付什么，—或者不允诺交付什么。<em>不对这些事项作出陈述，你就回到了靠巧合编程，</em>那是许多项目开始、结束、失败的地方。</p>
<h3 id="谁负责"><a href="#谁负责" class="headerlink" title="谁负责"></a>谁负责</h3><p>谁负责检查前条件，是调用者，还是被调用的例程？如果作为语言的一部分实现，答案是两者都不是：前条件是在调用者调用例程之后，但在进入例程自身之前，在幕后测试的。因而如果要对参数进行任何显示的检查，就必须由调用者来完成。</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><blockquote>
<p>无论何时你发现自己在思考“但那当然不可能发生”，增加代码检查他。最容易的方法是使用断言<br>if it can’t happen, Use Assertions to ensure that it won’t.<br>不仅仅在测试环境打开断言，书中更倾向于生产环境也把断言开着，只把那些特别影响性能的断言关掉。</p>
</blockquote>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul>
<li>fix the problem, Not the Blame</li>
<li>don’t panic,无论上面压力多大，或者dead line多近了，首先保持平常心去调试bug。</li>
<li>责任别外卸, bug 有可能存在于OS、编译器、或是第三方库，但这不应该是你的第一想法。有大得多的可能性的是，bug就存在于正在开发的代码中。</li>
<li>重现bug,无须弄太多复杂人工操作，有时候一句代码就可以重现了。</li>
<li>跟反馈人员面谈，搜集更多的数据</li>
<li>必须强硬地测试<em>边界条件</em>。</li>
<li><em>不要假定，要证明！</em></li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="什么是异常情况"><a href="#什么是异常情况" class="headerlink" title="什么是异常情况"></a>什么是异常情况</h3><p>异常很少应作为程序的正常流程的一部分使用；异常应保留给意外事件。假定某个未被抓住的异常会终止你的程序了，问问你自己：“如果移走所有的异常处理器，这些代码是否仍然能运行？”如果答案是“否”，那么异常也许就正在被用在非异常的情形中。<br>e.g. 你的代码试图打开一个文件进行读取，而该文件并不存在，是否应该引发异常，这里分2种情况讨论：</p>
<ol>
<li>如果你确定文件就应该在哪里，那么引发异常就有正当理由。</li>
<li>你不确定文件是否存在，也就找不到文件看来就不是异常情况了，这里适合用错误返回。<blockquote>
<p>Use Exceptions for Exceptional Problems.<br>异常表示即时的、非局部的控制转移。<br>如果把异常当成正常流程处理的话，代码的可读性和可维护性将受到打击。</p>
</blockquote>
</li>
</ol>
<h3 id="OC有-try-catch-有异常处理机制，为什么业界好像不怎么推荐使用？"><a href="#OC有-try-catch-有异常处理机制，为什么业界好像不怎么推荐使用？" class="headerlink" title="OC有@try @catch 有异常处理机制，为什么业界好像不怎么推荐使用？"></a>OC有@try @catch 有异常处理机制，为什么业界好像不怎么推荐使用？</h3><ol>
<li>因为try catch无法捕获UncaughtException，而OC中大部分crash如：<em>内存溢出、野指针等都是无法捕获的</em>，而能捕获的只是像数组越界之类（这真心需要catch么？注：完全可以通过代码判断避免），所以try catch对于OC来说，比较鸡肋。</li>
<li>简单的来说，Apple虽然同时提供了错误处理（NSError）和异常处理（exception）两种机制，但是Apple更加提倡开发者使用NSError来处理程序运行中可恢复的错误。而异常被推荐用来处理不可恢复的错误。    原因有几个，在非gc情况下，exception容易造成内存管理问题（文档有描述即使是arc下，也不是安全的）；exception使用block造成额外的<em>开销</em>，<em>效率较低</em>等等，另外这也的确是Cocoa开发者的习惯。</li>
<li>很多人在编程中，错误了使用了Try-Catch，把异常处理机制用在了核心逻辑中。把其当成了一个变种的GOTO使用。把大量的逻辑写在了Catch中。弱弱的说一句，这种情况干嘛不用ifelse呢。<br>综上3点原因，建议大家还是在代码中少用，可以通过判断是否非空、判断数组是否越界等方法进行处理。但是如果需要在代码中处理一些异常，也是可以的。</li>
</ol>
<h3 id="错误处理器"><a href="#错误处理器" class="headerlink" title="错误处理器"></a>错误处理器</h3><p>错误处理器是检测到错误调用的例程。</p>
<h2 id="配平资源"><a href="#配平资源" class="headerlink" title="配平资源"></a>配平资源</h2><p>e.g-》p105 遵循谁打开，谁关闭，谁分配，谁释放原则。与iOS早期的MRC思想一样。</p>
<h3 id="嵌套的分配"><a href="#嵌套的分配" class="headerlink" title="嵌套的分配"></a>嵌套的分配</h3><ol>
<li>以与资源分配次序想法的次序解除资源的分配。（reverse）</li>
<li>在代码不同的地方分配同一组资源时，总是以相同的次序分配他们。（有效降低死锁）</li>
</ol>
<h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><blockquote>
<p>保持灵活的一种方法是少写代码。改动代码会使你引入新bug的可能性增大。<br>个人觉得减少重复，减少硬编码的意思。<br>把你的代码组织成最小组织单位（模块），并限制他们的交互。</p>
</blockquote>
<h3 id="函数的得墨忒耳定律"><a href="#函数的得墨忒耳定律" class="headerlink" title="函数的得墨忒耳定律"></a>函数的得墨忒耳定律</h3><blockquote>
<p>Minimize Coupling Between Modules<br>百科了一下<br>很多面向对象程序设计语言用”.”表示对象的域的解析算符，因此得墨忒耳定律可以简单地陈述为“只使用一个.算符”。因此，a.b.Method()违反了此定律，而a.Method()不违反此定律。一个简单例子是，人可以命令一条狗行走（walk），但是不应该直接指挥狗的腿行走，应该由狗去指挥控制它的腿如何行走。</p>
</blockquote>
<pre><code>public void show Balance (BankAccount acct) 
{
   Money amt = acct.getBalance();
   printToScreen(amt.printFormat());
}
</code></pre><p>acct 为传入参数对象，可以调用acc.getBalance(),但amt.printFormat()就相当于acc.getBalance().printFormat(), 即a.b.Method(),违反了得墨忒耳定律，因此，可略去中间Money对象，直接在BankAccount中新增个printBalance()方法即可。</p>
<pre><code>public void show Balance (BankAccount acct) 
{
   acct.pintBalance();
}
</code></pre><p>实践中，其实就意味着编写大量的包装方法，让一个包工头类将请求转发给下面的分工。</p>
<blockquote>
<p>一句话就是模块之间仅仅暴露<em>有限 关键</em>信息，作<em>最少</em>交互。</p>
</blockquote>
<h2 id="元程序设计"><a href="#元程序设计" class="headerlink" title="元程序设计"></a>元程序设计</h2><h3 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h3><p>使系统变得高度可配置，用元数据描述应用的配置选项。（这里说得有点像OSX 的系统偏好设置吧？）</p>
<h3 id="元数据驱动的应用"><a href="#元数据驱动的应用" class="headerlink" title="元数据驱动的应用"></a>元数据驱动的应用</h3><blockquote>
<p>put Abstractions in Code, Details in Metadata</p>
</blockquote>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><blockquote>
<p>Always Design for Concurrency<br>本书对并发非常看重，还给了个将流程工作向并发操作的小tips:<br>Analyze Workflow to Improve Concurrency<br>将需求流程转化为UML图，其中没有指入箭头的项目可以考虑并发操作。</p>
</blockquote>
<h2 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h2><h2 id="靠巧合编程"><a href="#靠巧合编程" class="headerlink" title="靠巧合编程"></a>靠巧合编程</h2><p>要清楚，我们身处雷区，如果依靠巧合编程，就如同在雷区碰运气排雷一样，随时爆炸身亡了。<br>这个雷我上个月就踩过。<br>当时意识不够，没意识到线上环境是如此大凶险的，擅自用uid为key存储数据了。在开发这个版本的时候，一直没出问题，想当然地认为产品上线也会顺顺利利的，殊不知，在n个版本之前，已经有同事用过uid来存储另一种类型的数据了，尽管这个数据早在版本迭代中废弃没用了，但一直存在与用户机器中。而OC 恰恰又是动态语言，不管你代码写他是什么，数据类型要到运行时才能确定···。<br>种种巧合在这个时间点堆砌起来，bang的一声，就这样炸开了。</p>
<h3 id="怎么巧合编程"><a href="#怎么巧合编程" class="headerlink" title="怎么巧合编程"></a>怎么巧合编程</h3><p>好了，言归正传，巧合编程主要包括实现的偶然性，语境的偶然性和隐含的假定。<br>当初我犯了实现的偶然性和隐含的假定。假定了在我之前没人用过uid作key存过数据，况且既然版本测试没问题了，就真的没问题了。</p>
<h3 id="怎样深思熟虑地编程"><a href="#怎样深思熟虑地编程" class="headerlink" title="怎样深思熟虑地编程"></a>怎样深思熟虑地编程</h3><ul>
<li>总是意识到你在做什么</li>
<li>不要盲目地编程，使用不熟悉，不理解的第三方库，技术等</li>
<li>按照计划行事</li>
<li>依靠可靠的事物。不要依靠<em>巧合</em>或<em>假定</em>。</li>
<li>为你的假设建立文档。有助于澄清假定，并传递给他人。</li>
<li>不要只测试你的代码，还要测试你的假定。尝试<em>证明</em>假定。</li>
<li>为工作划分优先级。把时间花在重要的方面</li>
<li>不要做历史的奴隶。不要让已有的代码支配将来的代码。如果不再适用，所有的代码都应该替换。</li>
</ul>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><h3 id="when："><a href="#when：" class="headerlink" title="when："></a>when：</h3><ul>
<li>重复。当发现违反DRY原则的时候。</li>
<li>非正交设计</li>
<li>过时的知识</li>
<li>性能</li>
</ul>
<h3 id="why"><a href="#why" class="headerlink" title="why:"></a>why:</h3><p>  把需要重构的代码当做是一种“肿瘤”，你现在可以手术，趁它还小把它取出来，你也可以等他增大并扩散—但那时再切除它就会更昂贵、更危险。等再久一些，“病人”就有可能会丧命。</p>
<h3 id="how-2"><a href="#how-2" class="headerlink" title="how:"></a>how:</h3><ul>
<li>不要试图在重构的同时新增功能。</li>
<li>在开始重构之前，确保你拥有<em>良好的测试</em>。尽可能经常运行这些测试。这样，如果你的改动破坏了任何东西，你就能很快知道。</li>
<li>采取<em>短小、深思熟虑</em>的步骤：把某个字段从一个类移往另一个，把两个类似的方法融合进超类中。重构常常设计到进行许多局部改动，继而产生更大规模的改动。如果你使你的步骤保持短小，并在每个步骤之后进行测试，你能够后期避免长时间的调试。</li>
<li>看到不怎么合理的代码时，既要修正他，也要修正依赖于他的每样东西</li>
<li><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2></li>
</ul>
<h3 id="what-2"><a href="#what-2" class="headerlink" title="what"></a>what</h3><p>在隔离状态下，对每个模块进行测试，目的是检验其行为。<br>软件的单元测试，是指对模块进行演练的代码。</p>
<h3 id="how-3"><a href="#how-3" class="headerlink" title="how"></a>how</h3><p>编写测试代码，确保给定的单元遵守其合约。通过广泛的测试用例与边界条件，测试模块是否实现了它允诺的功能。<br>测试模块之间相互依赖的情况：<br>依赖于LinkedList 和 Sort 的模块 A</p>
<ol>
<li>全面测试Linklist的合约</li>
<li>全面测试Sort的合约</li>
<li>测试A的合约，它依赖于另外两个合约，但没有直接暴露他们。<br>这种风格的测试要求你首先测试模块的子组件。一旦子组件得到了检验，就可以测试模块本身。</li>
</ol>
<p>之前听过很多大牛的分享，都很强烈使用单元测试。我们项目是否也考虑下引入？</p>
<h2 id="before-the-Project-在项目开始之前"><a href="#before-the-Project-在项目开始之前" class="headerlink" title="before the Project 在项目开始之前"></a>before the Project 在项目开始之前</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>需求很少存在于表面上。通常，他们深深埋藏在层层假定、误解和政治手段的下面<br>Don’t gather requirements - Dig for them</p>
<h4 id="挖掘需求"><a href="#挖掘需求" class="headerlink" title="挖掘需求"></a>挖掘需求</h4><p>Work with a User to think like a User</p>
<h3 id="建立需求文档"><a href="#建立需求文档" class="headerlink" title="建立需求文档"></a>建立需求文档</h3><p>当遇到一些合适的、描述应用需要做什么的情景，把它们写下来，并发布，每个人都可以以此为据用作讨论的基础文档—开发者、最终用户、以及项目出资人。</p>
<h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><p>可以用UML活动图捕捉工作流，而且有时要为手边的事务建模。概念图很有用，但真正的用例是具有<em>层次结构</em>和<em>交叉链接</em>的文字描述，用例间可以互相嵌套。</p>
<h4 id="规定过度"><a href="#规定过度" class="headerlink" title="规定过度"></a>规定过度</h4><p>制作需求文档的一大危险是太过具体，好的需求文档会保持抽象，在涉及需求的地方，<em>最简单的、能准确</em>地反应商业需求的陈述是最好的。这并非意味着可以含糊不清—你必须把底层的语意不变项当做需求进行捕捉，并把及的或当前的工作实践当做政策记入文档。<br>  <em>需求不是架构，需求不是设计，也不是用户界面</em></p>
<h4 id="维护词汇表"><a href="#维护词汇表" class="headerlink" title="维护词汇表"></a>维护词汇表</h4><p>一旦开始讨论需求，用户和领域专家就会使用对他们有特定含义的属于。e.g.“客户”和“顾客”。<br>  要创建并维护项目词汇表（project glossary）—定义项目中使用专业术语的地方。项目的所有参与者，从最终用户到设计人员，都应该使用这个词汇表，以确保<strong>一致性</strong>。</p>
<h4 id="把项目文档发布到内网上"><a href="#把项目文档发布到内网上" class="headerlink" title="把项目文档发布到内网上"></a>把项目文档发布到内网上</h4><h2 id="解开不可能解开的谜题"><a href="#解开不可能解开的谜题" class="headerlink" title="解开不可能解开的谜题"></a>解开不可能解开的谜题</h2><p>秘诀是确定真正的（而不是想象的）约束，并在其中找出解决方法。有些约束是绝对的；有些则只是<em>先入之见</em>。</p>
<blockquote>
<p>Don’t think Outside the Box — find the box.</p>
</blockquote>
<h2 id="是良好的判断，还是拖延？"><a href="#是良好的判断，还是拖延？" class="headerlink" title="是良好的判断，还是拖延？"></a>是良好的判断，还是拖延？</h2><p><em>构建原型</em>，选择一个你觉得会有困难的地方，开始进行某种“概念验证”。在典型情况下，可能会发生两种情况：</p>
<ol>
<li>开始不久，就觉得自己再浪费时间，这种厌烦可能很好标明了，你最初的勉强只是希望推迟启动。—》<em>放弃原型，回到真正的开发中</em></li>
<li>随着原型取得进展，可能得到启示：突然意识到有些基本的前提错了。不仅如此，你还清楚的看到可以怎样纠正错误。—》愉快地放弃原型，投入正常的项目。<br>当你做出决定把<em>构建原型</em>当作调查你的不适的一种方法时，一定要记住<strong>为何这样做</strong>。</li>
</ol>
<h2 id="规范陷阱"><a href="#规范陷阱" class="headerlink" title="规范陷阱"></a>规范陷阱</h2><p>编写程序规范就是把需求规约到程序员能够接管的程度的过程。这是个交流活动，旨在解释并澄清系统的需求。</p>
<p><em>没有给编码者留下任何解释余地的设计会剥夺了他们发挥技巧和艺术才能的权利。</em></p>
<h2 id="圆圈与箭头"><a href="#圆圈与箭头" class="headerlink" title="圆圈与箭头"></a>圆圈与箭头</h2><blockquote>
<p>Don’t be a slave to Formal Methods<br>Expensive TOOls do not Produce Better Designs<br><em>注重实效的程序员</em>批判的看待方法学，并从各种方法学中提取精华，融合成一套工作习惯。<br>你应该不断努力提炼和改善你的开发过程。绝不要把方法学的代办限制当做你的世界的边界。</p>
</blockquote>
<h2 id="注重实效的项目"><a href="#注重实效的项目" class="headerlink" title="注重实效的项目"></a>注重实效的项目</h2><p>一旦参与项目的人员超过一个，你就需要建立一些基本原则，并相应地分派任务。</p>
<h3 id="注重实效的团队"><a href="#注重实效的团队" class="headerlink" title="注重实效的团队"></a>注重实效的团队</h3><h4 id="不要留破窗户"><a href="#不要留破窗户" class="headerlink" title="不要留破窗户"></a>不要留破窗户</h4><h4 id="煮青蛙"><a href="#煮青蛙" class="headerlink" title="煮青蛙"></a>煮青蛙</h4><p>确保每个人主动监视环境的变化—监视好任何不在最初约定中的东西。</p>
<h4 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h4><h4 id="DRY"><a href="#DRY" class="headerlink" title="DRY"></a>DRY</h4><h4 id="正交性-1"><a href="#正交性-1" class="headerlink" title="正交性"></a>正交性</h4><p>按照功能划分团队。让各团队按照个人的能力，在内部自行进行组织。每个团队都按照他们约定的承诺，对项目中的其他团队富有责任。<br>我们是在需求内聚的、在很大程序上自足的团队—和使代码模块化是使用的标准完全一样</p>
<h4 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h4><ul>
<li>一切都要自动化_<br>don’t use manual Procedure<br>使用shell脚本，cron自动化工具</li>
<li>项目编译<br>makefile</li>
<li>生成代码</li>
<li>回归测试</li>
</ul>
<h3 id="无情的测试"><a href="#无情的测试" class="headerlink" title="无情的测试"></a>无情的测试</h3><p>开发过程中就要找到自己的bug,以免以后经受由他人找到我们的不过所带来的羞耻。</p>
<blockquote>
<p>test early, test often, test automatically.<br>好的项目拥有的测试代码可能比产品代码还要多。<br>coding ain’t done till all the tests run</p>
</blockquote>
<h4 id="what-3"><a href="#what-3" class="headerlink" title="what"></a>what</h4><ul>
<li>单元测试</li>
<li>集成测试</li>
<li>验证和校验</li>
<li>资源耗尽、错误及恢复</li>
<li>性能测试</li>
<li>可用性测试</li>
</ul>
<h5 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h5><p>对某个模块进行演练的代码</p>
<h5 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h5><p>检测多个模块所组成的系统的集成问题</p>
<h5 id="验证和校验"><a href="#验证和校验" class="headerlink" title="验证和校验"></a>验证和校验</h5><p>是否用户所需？是否满足系统的功能需求？</p>
<h5 id="资源耗尽、错误及恢复"><a href="#资源耗尽、错误及恢复" class="headerlink" title="资源耗尽、错误及恢复"></a>资源耗尽、错误及恢复</h5><p>代码可能遇到的一些限制包括：</p>
<ul>
<li>内存空间</li>
<li>磁盘空间</li>
<li>CPU带宽</li>
<li>挂钟时间</li>
<li>磁盘带宽</li>
<li>网络带宽</li>
<li>调色板</li>
<li>视频分辨率<h5 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h5></li>
<li>性能测试</li>
<li>压力测试</li>
<li>负载测试<br>是否满足一下的性能需求— 预期的用户数、连接数、或每秒的事务数？<h4 id="how-4"><a href="#how-4" class="headerlink" title="how"></a>how</h4><h5 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h5>把当前测试的输出与之前的（或已知的）进行对比。确认今天修的bug没有破坏昨天的代码。<h5 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h5></li>
<li>大量</li>
<li>强调边界条件</li>
<li>具有特定统计属性的数据<h5 id="演练GUI系统"><a href="#演练GUI系统" class="headerlink" title="演练GUI系统"></a>演练GUI系统</h5></li>
</ul>
<h5 id="对测试进行测试"><a href="#对测试进行测试" class="headerlink" title="对测试进行测试"></a>对测试进行测试</h5><blockquote>
<p>use Saboteurs to test your Testing<br>故意引入bug,并证实测试能抓住他们</p>
</blockquote>
<h5 id="彻底测试"><a href="#彻底测试" class="headerlink" title="彻底测试"></a>彻底测试</h5><blockquote>
<p>test state Coverage, Not code Cerage<br>测试尝试去覆盖所有代码的状态。</p>
</blockquote>
<h4 id="when-1"><a href="#when-1" class="headerlink" title="when"></a>when</h4><p>任何产品代码一旦存在，就需要进行测试<br>大多数测试都应该自动完成。<br>一旦测试人员找到了某个bug,应该对自动化测试进行修改，从此每次都自动化的检查那个特定的bug</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>为项目制作的文档基本上有两种：内部文档和外部文档。</p>
<h3 id="内部文档"><a href="#内部文档" class="headerlink" title="内部文档"></a>内部文档</h3><h4 id="代码中的注释"><a href="#代码中的注释" class="headerlink" title="代码中的注释"></a>代码中的注释</h4><p>注释应该讨论为何做某事、它的目的和目标（因为代码已经说明他是怎么完成的）。<br>我们喜欢看到见得模块级头注释、关于重要数据与类型的注释、以及给每个类和没个方法所加的简要头注释，用以描述函数的<em>用法</em>和<em>任何不明了的</em>事情。 </p>
<h2 id="傲慢与偏见"><a href="#傲慢与偏见" class="headerlink" title="傲慢与偏见"></a>傲慢与偏见</h2><blockquote>
<p>注重实效的程序员不会逃避责任。相反，我们乐于接受挑战，乐于是我们的专业知识广为人知。<br>不应该怀着猜忌心组织要查看你的代码的人；出于同样的原因，你应该带着尊重对待他人的代码。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/12/仿支付宝tableView/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/12/仿支付宝tableView/" itemprop="url">
                  仿支付宝tableView
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-12T18:27:24+08:00">
                2016-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>支付宝首页tableView的大概有如下几个特点：</p>
<ol>
<li>下拉tableVIew,”headerView”不随之下滑</li>
<li>上拉tableView,”headerView”随之下滑</li>
<li>不够力，自动滑回</li>
</ol>
<p>而单纯的tableHeaderView,sectionHeader啊，是无法实现这两个功能的。<br>以下是我的实现思路：<br>1 创建一个View，作为“headerView”</p>
<pre><code>- (void)initHeaderView
{
    _headerView = [[MyHeaderView alloc] initWithFrame:CGRectMake(0, 64, DRScreenWidth, HeaderViewHeight)];
    _headerView.backgroundColor = [UIColor yellowColor];
    [self.view addSubview:_headerView];
}
</code></pre><p>2 创建tableView,将其contentInset设在headerView下沿</p>
<pre><code>- (void)initTableView
{
    _tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0, DRScreenWidth, DRScreenHeight) style:UITableViewStylePlain];
    _tableView.dataSource = self;
    _tableView.delegate = self;
    _tableView.backgroundColor = [UIColor purpleColor];
    _tableView.contentInset = UIEdgeInsetsMake(HeaderViewHeight, 0, 0, 0);
    [_tableView addObserver:self forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew context:nil];
    [self.view addSubview:_tableView];
}
</code></pre><p>看到这里，可能有的读者会有疑问，<br>    _tableView.contentInset = UIEdgeInsetsMake(HeaderViewHeight, 0, 0, 0);<br>这句有何意义呢？干嘛不直接把tableView的frame放在headerView下面就好了？<br>其实这句大有玄机。我们继续看HeaderView里面究竟实现了什么。</p>
<pre><code>- (instancetype)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        [self initBtn];
        [self addObserver];
    }
    return self;
}
- (void)addObserver
{
    [self addObserver:self forKeyPath:@&quot;frame&quot; options:NSKeyValueObservingOptionNew context:nil];
}

#pragma mark - KVO
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context
{
    CGRect rect = [change[NSKeyValueChangeNewKey] CGRectValue];
    NSLog(@&quot;head view height = %f&quot;,rect.size.height);
    CGFloat height = rect.size.height;
    if (height &lt; visibleOffset) {
        _btn.hidden = YES;
        _aView.hidden = YES;
    } else {
        _btn.hidden = NO;
        _aView.hidden = NO;
    }
}
</code></pre><p>这里的kvo主要是为了通过监听frame的变化来控制subView的显影。<br>而下面这句才能解释上面那个问题：</p>
<pre><code>#pragma mark - touch
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
    UIView *view = [super hitTest:point withEvent:event];
    if ([view isKindOfClass:[self class]]) {

        return nil;
    }
    return view;
}
</code></pre><p>重写了hittest,反正让用户怎么也摸不到自身！就是为了解决当触摸点在headerView上面的时候，hitTest返回对象是跌在他下面的tableView,来让tableView响应滑动。<br>好了，回到正题。<br>我们好像还没实现初衷的3个特性。<br>第1，2点也是通过KVO来改变headerView的height或origin.y实现的。<br>首先看看改变height：</p>
<pre><code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context
{
    if ([keyPath isEqualToString:@&quot;contentOffset&quot;]) {
        CGPoint offset = [change[NSKeyValueChangeNewKey] CGPointValue];
        NSLog(@&quot;KVO:%f&quot;,offset.y);

        if (offset.y &gt; -(HeaderViewHeight +navigationBarHeightPlusStatusBarHeight) &amp;&amp; offset.y &lt; -navigationBarHeightPlusStatusBarHeight) {
            CGRect frame = _headerView.frame;
            frame.size.height = - navigationBarHeightPlusStatusBarHeight - offset.y;
            _headerView.frame = frame;
        } else if (offset.y &lt;= -(HeaderViewHeight +navigationBarHeightPlusStatusBarHeight)) {
//tableView下滑，headerView保持不变
            _headerView.frame = CGRectMake(0, navigationBarHeightPlusStatusBarHeight, DRScreenWidth, HeaderViewHeight);
        } else if (offset.y &gt;= -navigationBarHeightPlusStatusBarHeight) {
//tableView上滑，直到两者上沿重叠，headerView高度设0
            _headerView.frame = CGRectMake(0, navigationBarHeightPlusStatusBarHeight, DRScreenWidth, 0);
        }
    }
}
</code></pre><p>上面的逻辑很清楚了，主要是通过改变headerView的高度，来造成headerView随tableView滑动的错觉。<br><img src="/2016/11/12/仿支付宝tableView/changeHeightLight.gif" title="change height"><br>当然，也可以改变HeaderView的y来实现。</p>
<p>看代码：</p>
<pre><code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context
{
    if ([keyPath isEqualToString:@&quot;contentOffset&quot;]) {
        CGPoint offset = [change[NSKeyValueChangeNewKey] CGPointValue];
        NSLog(@&quot;KVO:%f&quot;,offset.y);
        if (offset.y &gt; -(HeaderViewHeight +navigationBarHeightPlusStatusBarHeight) &amp;&amp; offset.y &lt; -navigationBarHeightPlusStatusBarHeight) {
            CGRect frame = _headerView.frame;
            frame.origin.y  = fabs(offset.y) - HeaderViewHeight;
            _headerView.frame = frame;
        } else if (offset.y &lt;= -(HeaderViewHeight +navigationBarHeightPlusStatusBarHeight)) {
            _headerView.frame = CGRectMake(0, navigationBarHeightPlusStatusBarHeight, DRScreenWidth, HeaderViewHeight);
        } else if (offset.y &gt;= -navigationBarHeightPlusStatusBarHeight) {
            _headerView.frame = CGRectMake(0, -HeaderViewHeight+navigationBarHeightPlusStatusBarHeight, DRScreenWidth, HeaderViewHeight);
        }
    }
}
</code></pre><img src="/2016/11/12/仿支付宝tableView/changeOriginY-light.gif" title="change height">
<p>最后，就是第3个特性了：</p>
<pre><code>#pragma mark - scrollview delegate
- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset
{
//    NSLog(@&quot;willENdDragging:%f&quot;,scrollView.contentOffset.y);
    if (targetContentOffset-&gt;y &gt; -132 &amp;&amp; targetContentOffset-&gt;y &lt; -navigationBarHeightPlusStatusBarHeight) {
        *targetContentOffset = CGPointMake(0, -navigationBarHeightPlusStatusBarHeight);
    } else if (targetContentOffset-&gt;y &lt;= -132 &amp;&amp; targetContentOffset-&gt;y &gt; -(navigationBarHeightPlusStatusBarHeight + HeaderViewHeight)) {
        *targetContentOffset = CGPointMake(0, -(navigationBarHeightPlusStatusBarHeight + HeaderViewHeight));
    }
}
</code></pre><p>实现这个代理就👌。关于这个代理详细可看我上一篇文章<a href="https://takeroro.github.io/2016/09/28/tableView串烧/" target="_blank" rel="noopener">UITableView串烧</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/28/tableView串烧/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/28/tableView串烧/" itemprop="url">
                  tableView 大串烧
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-28T10:30:18+08:00">
                2016-09-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于UITableView-串烧"><a href="#关于UITableView-串烧" class="headerlink" title="关于UITableView  串烧"></a>关于UITableView  串烧</h1><h2 id="滑动到指定位置"><a href="#滑动到指定位置" class="headerlink" title="滑动到指定位置"></a>滑动到指定位置</h2><pre><code>- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset 
{
//这里将注意力放在targetContentOffset 存取就好了，设置这个滑动去指定Offset
if (targetContentOffset -&gt; y &lt; aValue) {
        *targetContentOffset = CGPointMake(expectX, expectY);
}
}
</code></pre><p>velocity.y > 0 有向下划的趋势<br>velocity.y > 0 有向上滑的趋势<br>项目中的具体情况没有这么简单，tmd外面一个大tableView，cell里面又装着好几个tableView ,这就需要用delegate 或者 notification由下至上，将这个回调传递给最外层的controller了。</p>
<h2 id="另外再贴一下这种情况上下滑动两个tableView相应didScroll方法的回调实现"><a href="#另外再贴一下这种情况上下滑动两个tableView相应didScroll方法的回调实现" class="headerlink" title="另外再贴一下这种情况上下滑动两个tableView相应didScroll方法的回调实现"></a>另外再贴一下这种情况上下滑动两个tableView相应didScroll方法的回调实现</h2><pre><code>//_tableView : 大tableView, 
//scrollView：cell里面装的tableView,小tableView
//maxOffsetY: 大tableView能滑动的最大位置，可用大tableViewContentSizeY - 小tableView.frame.height
//originOffsetY:大tableView的originOffsetY
- (void)innerTableViewDidScroll:(UIScrollView *)scrollView
{
    CGPoint scrollViewPoint = scrollView.contentOffset;
    CGPoint detailTableviewContentOffset = _tableView.contentOffset;
//需要设置maxOffset 和  originalOffsetY即可
    CGFloat maxOffsetY = headerViewHeight - 64;
    if (scrollViewPoint.y &gt; 0 &amp;&amp; detailTableviewContentOffset.y &lt; maxOffsetY) {
        CGFloat detailTableViewContentOffsetY = originalOffsetY;
        if (scrollViewPoint.y + detailTableviewContentOffset.y &lt; maxOffsetY) {
            detailTableViewContentOffsetY = scrollViewPoint.y + detailTableviewContentOffset.y;
        } else {
            detailTableViewContentOffsetY = maxOffsetY;
        }
        [_tableView setContentOffset:CGPointMake(detailTableviewContentOffset.x, detailTableViewContentOffsetY)];
        CGRect scrollViewBounds = scrollView.bounds;
        scrollViewBounds.origin = CGPointZero;
        scrollView.bounds = scrollViewBounds;
    }
    if (scrollViewPoint.y &lt; 0 &amp;&amp; detailTableviewContentOffset.y &gt; 0) {
        CGFloat detailTableViewContentOffsetY = originalOffsetY;
        if (scrollViewPoint.y + detailTableviewContentOffset.y &gt; 0) {
            detailTableViewContentOffsetY = scrollViewPoint.y + detailTableviewContentOffset.y;
        } else {
            detailTableViewContentOffsetY = originalOffsetY;
        }
        [_tableView setContentOffset:CGPointMake(detailTableviewContentOffset.x, detailTableViewContentOffsetY)];
        CGRect scrollViewBounds = scrollView.bounds;
        scrollViewBounds.origin = CGPointZero;
        scrollView.bounds = scrollViewBounds;
    }
    NSLog(@&quot;container tableview contentOffset:%f&quot;, scrollViewPoint.y);
}
</code></pre><p>使用时需要设置maxOffset 和  originalOffsetY即可<br>还有这3行值得注意的：<br>            CGRect scrollViewBounds = scrollView.bounds;<br>             scrollViewBounds.origin = CGPointZero;<br>             scrollView.bounds = scrollViewBounds;<br>每次移动后记得将origin 归零。</p>
<h2 id="自定navigationBar-alpha-随tableView-滑动变化"><a href="#自定navigationBar-alpha-随tableView-滑动变化" class="headerlink" title="自定navigationBar alpha 随tableView 滑动变化"></a>自定navigationBar alpha 随tableView 滑动变化</h2><pre><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView
{
    CGFloat scrollOffsetY = scrollView.contentOffset.y;
    [self setNavigationBarAlphaWithContentOffset:scrollOffsetY];
}
- (void)setNavigationBarAlphaWithContentOffset:(CGFloat)y
{
    _navigationBar.alpha = y / (headerViewHeight - 64);
}
</code></pre><p>当navigationBar 下沿到达 headerViewHeight 的下沿时，navigationBar.alpha = 1;<br>需要注意的，分母记得减去statusbarheight(20) + navigationBarHeight(44)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/23/TollFreeBridging/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/23/TollFreeBridging/" itemprop="url">
                  Toll-free bridging
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-23T12:14:39+08:00">
                2016-08-23
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="what-is-Toll-free-bridging"><a href="#what-is-Toll-free-bridging" class="headerlink" title="what is Toll-free bridging"></a>what is Toll-free bridging</h1><p>简要言之，就是CF(core foundation) 和 Foundation 之间的某些对象可以无缝强制转换。<br>e.g. NSLocale 和 CFLocaleRef ,强转就可以直接用了！</p>
<pre><code>NSLocale *gbNSLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_GB&quot;];
CFLocaleRef gbCFLocale = (__bridge CFLocaleRef)gbNSLocale;//不转移所有权，还是归arc管理计数
CFStringRef cfIdentifier = CFLocaleGetIdentifier(gbCFLocale);
NSLog(@&quot;cfIdentifier: %@&quot;, (__bridge NSString *)cfIdentifier);
// Logs: &quot;cfIdentifier: en_GB&quot;

CFLocaleRef myCFLocale = CFLocaleCopyCurrent();//有copy,create等字眼，就拥有了cf对象了，需要手动管理计数
NSLocale *myNSLocale = (NSLocale *)CFBridgingRelease(myCFLocale);//所用权移交arc
NSString *nsIdentifier = [myNSLocale localeIdentifier];
CFShow((CFStringRef)[@&quot;nsIdentifier: &quot; stringByAppendingString:nsIdentifier]);
</code></pre><h1 id="when-to-release"><a href="#when-to-release" class="headerlink" title="when to release?"></a>when to release?</h1><p>普通的bridge oc->cf，是不用手动管理计数的。<br>根据wwdc2012,有create，copy或__bridge_retained等字眼，才需要手动CFBridgingRelease()。</p>
<p>参考：</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/14064336/arc-and-cfrelease" target="_blank" rel="noopener">https://stackoverflow.com/questions/14064336/arc-and-cfrelease</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/11/TimingFuntion/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/11/TimingFuntion/" itemprop="url">
                  TimingFuntion
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-07-11T22:14:39+08:00">
                2016-07-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数实现-TimingFunctionLinear-EaseIn-EaseOut-EaseInOut"><a href="#函数实现-TimingFunctionLinear-EaseIn-EaseOut-EaseInOut" class="headerlink" title="函数实现 TimingFunctionLinear,EaseIn,EaseOut,EaseInOut"></a>函数实现 TimingFunctionLinear,EaseIn,EaseOut,EaseInOut</h1><pre><code>@protocol TimingFuntionImp&lt;NSObject&gt;

-(CGFloat)update:(CGFloat)t;

@end

@interface TimingFuntionLinear : NSObject&lt;TimingFuntionImp&gt;

@end

@interface TimingFuntionEaseIn : NSObject&lt;TimingFuntionImp&gt;

@end

@interface TimingFuntionEaseOut : NSObject&lt;TimingFuntionImp&gt;

@end

@interface TimingFuntionEaseInOut : NSObject&lt;TimingFuntionImp&gt;

@end

@implementation TimingFuntionLinear

-(CGFloat)update:(CGFloat)t
{
    return t;
}

@end

@implementation TimingFuntionEaseIn

-(CGFloat)update:(CGFloat)t
{
    return powf(t, rateConstant);
}

@end

@implementation TimingFuntionEaseOut

-(CGFloat)update:(CGFloat)t{
    return 1.0-powf((1.0-t), rateConstant);
}

@end

@implementation TimingFuntionEaseInOut

-(CGFloat) update: (CGFloat) t
{
    t *= 2;
    if (t &lt; 1)
        return 0.5f * powf (t, rateConstant);
    else
        return 0.5f * (2.0f - powf(2.0 - t, rateConstant));
}

@end
</code></pre><p>原理挺简单，无非就是用一次函数，幂函数的图像来理解，重拾一下高中数学知识。。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/12/iOS图片加载/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Terrence">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="I'm Terrence">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="I'm Terrence" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/12/iOS图片加载/" itemprop="url">
                  iOS图片加载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-12T08:26:17+08:00">
                2016-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="imageName"><a href="#imageName" class="headerlink" title="imageName:"></a>imageName:</h2><p>（1）加载内存当中之后，会一直停留在内存当中，不会随着对象的销毁而销毁。</p>
<p>（2）加载进去图片之后，占用的内存归系统管理，我们无法管理。</p>
<p>（3）相同的图片，图片不会重复加载。</p>
<p>（4）加载到内存中后，占据内存空间较大。</p>
<h2 id="imageWithContentsofFile"><a href="#imageWithContentsofFile" class="headerlink" title="imageWithContentsofFile:"></a>imageWithContentsofFile:</h2><p>（1）加载到内存当中后，占据内存空间较小。</p>
<p>（2）相同的图片会被重复加载内存当中。</p>
<p>（3）对象销毁的时候，加载到内存中图片会随着一起销毁。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>imageName：由于一直停留在ram,所以更适合于经常用到的,且不太大的图片。<br>而imageWithContentsofFile：更适合用于图片数据较大的情况,且比较少用到的情况。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4ODk0NjY4NA==&amp;mid=2701605906&amp;idx=1&amp;sn=70429db34a999feade0ae16589e94ebf&amp;scene=2&amp;srcid=0504VXX8murZ7IIud4NfL5q5&amp;from=timeline&amp;isappinstalled=0#wechat_redirect" target="_blank" rel="noopener">这篇文章讲得比较细</a></p>
<h2 id="load子工程image-适配iOS7"><a href="#load子工程image-适配iOS7" class="headerlink" title="load子工程image(适配iOS7)"></a>load子工程image(适配iOS7)</h2><pre><code>+ (UIImage *)imageNamed:(NSString *)imageName withBundleName:(NSString *)bundleName
{
    NSBundle *bundle = [self bundleNamed:bundleName];
    if (SystemLessThan(8.0)) {
        NSString *path = [[bundle resourcePath] stringByAppendingPathComponent:imageName];
        UIImage *image = [UIImage imageWithContentsOfFile:path];
        return image;
    }
    else {
        return [UIImage imageNamed:imageName inBundle:bundle compatibleWithTraitCollection:nil];
    }
}

+ (NSBundle *)bundleNamed:(NSString *)bundleName
{
    NSString *bundlePath = [[NSBundle mainBundle] pathForResource:bundleName ofType:@&quot;bundle&quot;];
    return [NSBundle bundleWithPath:bundlePath];
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Terrence">
          <p class="site-author-name" itemprop="name">Terrence</p>
          <p class="site-description motion-element" itemprop="description">上帝只救自救者</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Terrence</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  




  
  

  

  

  

  


</body>
</html>
